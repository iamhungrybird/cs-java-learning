# 类文件结构

[Guide](https://javaguide.cn/article/)JavaJVM2021年11月9日约 2554 字

------

## [#](https://javaguide.cn/java/jvm/class-file-structure.html#一-概述)一 概述

在 Java 中，JVM 可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成`.class`文件最终运行在 Java 虚拟机之上。`.class`文件的二进制格式可以使用 [WinHexopen in new window](https://www.x-ways.net/winhex/) 查看。

![java虚拟机](images\desktop类文件结构概览.png)

可以说`.class`文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。

## [#](https://javaguide.cn/java/jvm/class-file-structure.html#二-class-文件结构总结)二 Class 文件结构总结

根据 Java 虚拟机规范，Class 文件通过 `ClassFile` 定义，有点类似 C 语言的结构体。

`ClassFile` 的结构如下：

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

通过分析 `ClassFile` 的内容，我们便可以知道 class 文件的组成。

![img](images\16d5ec47609818fc.jpeg)

下面这张图是通过 IDEA 插件 `jclasslib` 查看的，你可以更直观看到 Class 文件结构。

![img](images\image-20210401170711475.png)

使用 `jclasslib` 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。

下面详细介绍一下 Class 文件结构涉及到的一些组件。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-1-魔数-magic-number)2.1 魔数（Magic Number）

```java
    u4             magic; //Class 文件的标志
```

每个Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是**确定这个文件是否为一个能被虚拟机接收的 Class 文件**。

程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-2-class-文件版本号-minor-major-version)2.2 Class 文件版本号（Minor&Major Version）

```java
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
```

紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是**次版本号**，第 7 和第 8 位是**主版本号**。

每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 `javap -v` 命令来快速查看 Class 文件的版本号信息。

高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-3-常量池-constant-pool)2.3 常量池（Constant Pool）

```java
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
```

紧接着主次版本号之后的是常量池，常量池的数量是 `constant_pool_count-1`（**常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”**）。

常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：**开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．**

|               类型               | 标志（tag） |          描述          |
| :------------------------------: | :---------: | :--------------------: |
|        CONSTANT_utf8_info        |      1      |   UTF-8 编码的字符串   |
|      CONSTANT_Integer_info       |      3      |       整形字面量       |
|       CONSTANT_Float_info        |      4      |      浮点型字面量      |
|        CONSTANT_Long_info        |     ５      |      长整型字面量      |
|       CONSTANT_Double_info       |     ６      |   双精度浮点型字面量   |
|       CONSTANT_Class_info        |     ７      |   类或接口的符号引用   |
|       CONSTANT_String_info       |     ８      |    字符串类型字面量    |
|      CONSTANT_Fieldref_info      |     ９      |     字段的符号引用     |
|     CONSTANT_Methodref_info      |     10      |   类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info |     11      |  接口中方法的符号引用  |
|    CONSTANT_NameAndType_info     |     12      |  字段或方法的符号引用  |
|     CONSTANT_MothodType_info     |     16      |      标志方法类型      |
|    CONSTANT_MethodHandle_info    |     15      |      表示方法句柄      |
|   CONSTANT_InvokeDynamic_info    |     18      | 表示一个动态方法调用点 |

`.class` 文件可以通过`javap -v class类名` 指令来看一下其常量池中的信息(`javap -v class类名-> temp.txt` ：将结果输出到 temp.txt 文件)。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-4-访问标志-access-flags)2.4 访问标志(Access Flags)

在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 `public` 或者 `abstract` 类型，如果是类的话是否声明为 `final` 等等。

类访问和属性修饰符:

![类访问和属性修饰符](images\访问标志.png)

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-5-当前类-this-class-、父类-super-class-、接口-interfaces-索引集合)2.5 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合

```java
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
```

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 `java.lang.Object` 之外，所有的 java 类都有父类，因此除了 `java.lang.Object` 外，所有 Java 类的父类索引都不为 0。

接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 `implements` (如果这个类本身是接口的话则是`extends`) 后的接口顺序从左到右排列在接口索引集合中。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-6-字段表集合-fields)2.6 字段表集合（Fields）



```java
    u2             fields_count;//Class 文件的字段的个数
    field_info     fields[fields_count];//一个类会可以有个字段
```

字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。

**field info(字段表) 的结构:**

```java
field_info{
	u2  access_flags
	u2  name_index
	u2  descriptor_index
	u2  attributes_count
	attribute_info  attributes[attributes_count]
}
```

- **access_flags:** 字段的作用域（`public` ,`private`,`protected`修饰符），是实例变量还是类变量（`static`修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。
- **name_index:** 对常量池的引用，表示的字段的名称；
- **descriptor_index:** 对常量池的引用，表示字段和方法的描述符；
- **attributes_count:** 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；
- **attributes[attributes_count]:** 存放具体属性具体内容。

上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。

**字段的 access_flag 的取值:**

![字段的 access_flag 的取值](images\image-20201031084342859.png)

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-7-方法表集合-methods)2.7 方法表集合（Methods）



```java
    u2             methods_count;//Class 文件的方法的数量
    method_info    methods[methods_count];//一个类可以有个多个方法
```

methods_count 表示方法的数量，而 method_info 表示方法表。

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

**method_info(方法表的) 结构:**

```java
field_info{
	u2  access_flags
	u2  name_index
	u2  descriptor_index
	u2  attributes_count
	attribute_info  attributes[attributes_count]
}
```

**方法表的 access_flag 取值：**

![方法表的 access_flag 取值](images\image-20201031084248965.png)

注意：因为`volatile`修饰符和`transient`修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了`synchronized`、`native`、`abstract`等关键字修饰方法，所以也就多了这些关键字对应的标志。

### [#](https://javaguide.cn/java/jvm/class-file-structure.html#_2-8-属性表集合-attributes)2.8 属性表集合（Attributes）

```java
   u2             attributes_count;//此类的属性表中的属性数
   attribute_info attributes[attributes_count];//属性表集合
```

在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。

## [#](https://javaguide.cn/java/jvm/class-file-structure.html#参考)参考

- [https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.htmlopen in new window](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html)
- [https://coolshell.cn/articles/9229.htmlopen in new window](https://coolshell.cn/articles/9229.html)
- [https://blog.csdn.net/luanlouis/article/details/39960815open in new window](https://blog.csdn.net/luanlouis/article/details/39960815)
- 《实战 Java 虚拟机》

# 查看字节码文件

## 字节码

计算机比较“傻”，只认 0 和 1，这意味着我们编写的代码最终都要编译成机器码才能被计算机执行。Java 在诞生之初就提出了一个非常著名的宣传口号: "**一次编写，处处运行**"。

> **Write Once, Run Anywhere.**

为了这个口号，Java 的亲妈 Sun 公司以及其他虚拟机提供商发布了许多可以在不同平台上运行的 Java 虚拟机，而这些虚拟机都拥有一个共同的功能，那就是可以载入和执行同一种与平台无关的字节码（Byte Code）。

有了 Java 虚拟机的帮助，我们编写的 Java 源代码不必再根据不同平台编译成对应的机器码了，只需要生成一份字节码，然后再将字节码文件交由运行在不同平台上的 Java 虚拟机读取后执行就可以了。

如今的 Java 虚拟机非常强大，不仅支持 Java 语言，还支持很多其他的编程语言，比如说 Groovy、Scala、Koltin 等等。

![img](images\bytecode-dd31bbd6-c75c-4426-9437-c0f57ea3b86f.png)

来看一段代码吧。



```java
public class Main {
    private int age = 18;
    public int getAge() {
        return age;
    }
}
```

编译生成 Main.class 文件后，可以在命令行使用 `xxd Main.class` 打开 class 文件（我用的是 Intellij IDEA，在 macOS 环境下）。

![img](images\bytecode-bd941085-ff0e-4abf-a5f9-afb0493bfed7.png)

对于这些 16 进制内容，除了开头的 cafe babe，剩下的内容大致可以翻译成：啥玩意啊这......

同学们别慌，就从"cafe babe"说起吧，这 4 个字节称之为**魔数**，也就是说，只有以"cafe babe"开头的 class 文件才能被 Java 虚拟机接受，这 4 个字节就是字节码文件的身份标识。

目光右移，0000 是 Java 的次版本号，0037 转化为十进制是 55，是主版本号，Java 的版本号从 45 开始，每升一个大版本，版本号加 1，大家可以启动福尔摩斯模式，推理一下。

再往后面就是字符串常量池。《[class 文件open in new window](https://mp.weixin.qq.com/s/uMEZ2Xwctx4n-_8zvtDp5A)》那一篇我是顺着十六进制内容往下分析的，可能初学者看起来比较头大，这次我们换一种更容易懂的方式。

## [#](https://tobebetterjavaer.com/jvm/bytecode.html#_02、反编译字节码文件)反编译字节码文件

Java 内置了一个反编译命令 javap，可以通过 `javap -help` 了解 javap 的基本用法。

![img](images\bytecode-84b7af5c-93b1-4f63-bb30-946ab3d7e98c.png)

OK，我们输入命令 `javap -v -p Main.class` 来查看一下输出的内容。

```text
Classfile /Users/maweiqing/Documents/GitHub/TechSisterLearnJava/codes/TechSister/target/classes/com/itwanger/jvm/Main.class
  Last modified 2021年4月15日; size 385 bytes
  SHA-256 checksum 6688843e4f70ae8d83040dc7c8e2dd3694bf10ba7c518a6ea9b88b318a8967c6
  Compiled from "Main.java"
public class com.itwanger.jvm.Main
  minor version: 0
  major version: 55
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #3                          // com/itwanger/jvm/Main
  super_class: #4                         // java/lang/Object
  interfaces: 0, fields: 1, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #4.#18         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#19         // com/itwanger/jvm/Main.age:I
   #3 = Class              #20            // com/itwanger/jvm/Main
   #4 = Class              #21            // java/lang/Object
   #5 = Utf8               age
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/itwanger/jvm/Main;
  #14 = Utf8               getAge
  #15 = Utf8               ()I
  #16 = Utf8               SourceFile
  #17 = Utf8               Main.java
  #18 = NameAndType        #7:#8          // "<init>":()V
  #19 = NameAndType        #5:#6          // age:I
  #20 = Utf8               com/itwanger/jvm/Main
  #21 = Utf8               java/lang/Object
{
  private int age;
    descriptor: I
    flags: (0x0002) ACC_PRIVATE

  public com.itwanger.jvm.Main();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        18
         7: putfield      #2                  // Field age:I
        10: return
      LineNumberTable:
        line 6: 0
        line 7: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/itwanger/jvm/Main;

  public int getAge();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field age:I
         4: ireturn
      LineNumberTable:
        line 9: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/itwanger/jvm/Main;
}
SourceFile: "Main.java"
```

睁大眼睛瞧过去，感觉内容挺多的。同学们不要着急，我们来一行一行分析。

第 1 行：

```text
Classfile /Users/maweiqing/Documents/GitHub/TechSisterLearnJava/codes/TechSister/target/classes/com/itwanger/jvm/Main.class
```

字节码文件的位置。

第 2 行：

```text
Last modified 2021年4月15日; size 385 bytes
```

字节码文件的修改日期、文件大小。

第 3 行：

```text
SHA-256 checksum 6688843e4f70ae8d83040dc7c8e2dd3694bf10ba7c518a6ea9b88b318a8967c
```

字节码文件的 SHA-256 值。

第 4 行：

```text
Compiled from "Main.java"
```

说明该字节码文件编译自 Main.java 源文件。

第 5 行：

```text
public class com.itwanger.jvm.Main
```

字节码文件的类全名。

第 6 行 `minor version: 0`，次版本号。

第 7 行 `major version: 55`，主版本号。

第 8 行：

```text
flags: (0x0021) ACC_PUBLIC, ACC_SUPER
```

类访问标记，一共有 8 种。

![img](images\bytecode-d12d6983-f427-40d2-bb4b-3a2c6c4c7806.png)

表明当前类是 `ACC_PUBLIC | ACC_SUPER`。位运算符 `|` 的意思是如果相对应位是 0，则结果为 0，否则为 1，所以 `0x0001 | 0x0020` 的结果是 `0x0021`（需要转成二进制进行运算）。

第 9 行：

```text
this_class: #3                          // com/itwanger/jvm/Main
```

当前类的索引，指向常量池中下标为 3 的常量，可以看得出当前类是 Main 类。

第 10 行：

```text
super_class: #4                         // java/lang/Object
```

父类的索引，指向常量池中下标为 6 的常量，可以看得出当前类的父类是 Object 类。

第 11 行：

```text
interfaces: 0, fields: 1, methods: 2, attributes: 1
```

当前类有 0 个接口，1 个字段（age），2 个方法（`write()`方法和缺省的默认构造方法），1 个属性（该类仅有的一个属性是 SourceFIle，包含了源码文件的信息）。

## [#](https://tobebetterjavaer.com/jvm/bytecode.html#_03、常量池)常量池

接下来是 Constant pool，也就是字节码文件最重要的常量池部分。可以把常量池理解为字节码文件中的资源仓库，主要存放两大类信息。

1）字面量（Literal），有点类似 Java 中的常量概念，比如文本字符串，final 常量等。

2）符号引用（Symbolic References），属于编译原理方面的概念，包括 3 种：

- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

Java 虚拟机是在加载字节码文件的时候才进行的动态链接，也就是说，字段和方法的符号引用只有经过运行期转换后才能获得真正的内存地址。当 Java 虚拟机运行时，需要从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。

当前字节码文件中一共有 21 个常量，它们之间是有链接的，逐个分析会比较乱，我们采用顺藤摸瓜的方式，从上依次往下看，那些被链接的常量我们就点到为止。

*注*：

- `#` 号后面跟的是索引，索引没有从 0 开始而是从 1 开始，是因为设计者考虑到，“如果要表达不引用任何一个常量的含义时，可以将索引值设为 0 来表示”（《深入理解 Java 虚拟机》描述的）。
- `=` 号后面跟的是常量的类型，没有包含前缀 `CONSTANT_` 和后缀 `_info`。
- 全文中提到的索引等同于下标，为了灵活描述，没有做统一。

------

第 1 个常量：

```text
#1 = Methodref          #4.#18         // java/lang/Object."<init>":()V
```

类型为 Methodref，表明是用来定义方法的，指向常量池中下标为 4 和 18 的常量。

第 4 个常量：

```text
#4 = Class              #21            // java/lang/Object
```

类型为 Class，表明是用来定义类（或者接口）的，指向常量池中下标为 21 的常量。

第 21 个常量：

```text
#21 = Utf8               java/lang/Object
```

类型为 Utf8，UTF-8 编码的字符串，值为 `java/lang/Object`。

第 18 个常量：

```text
#18 = NameAndType        #7:#8          // "<init>":()V
```

类型为 NameAndType，表明是字段或者方法的部分符号引用，指向常量池中下标为 7 和 8 的常量。

第 7 个常量：

```text
#7 = Utf8               <init>
```

类型为 Utf8，UTF-8 编码的字符串，值为 `<init>`，表明为构造方法。

第 8 个常量：

```text
#8 = Utf8               ()V
```

类型为 Utf8，UTF-8 编码的字符串，值为 `()V`，表明方法的返回值为 void。

到此为止，第 1 个常量算是摸完了。组合起来的意思就是，Main 类使用的是默认的构造方法，来源于 Object 类。

------

第 2 个常量：

```text
#2 = Fieldref           #3.#19         // com/itwanger/jvm/Main.age:I
```

类型为 Fieldref，表明是用来定义字段的，指向常量池中下标为 3 和 19 的常量。

第 3 个常量：



```text
#3 = Class              #20            // com/itwanger/jvm/Main
```

类型为 Class，表明是用来定义类（或者接口）的，指向常量池中下标为 20 的常量。

第 19 个常量：



```text
#19 = NameAndType        #5:#6          // age:I
```

类型为 NameAndType，表明是字段或者方法的部分符号引用，指向常量池中下标为 5 和 6 的常量。

第 5 个常量：



```text
#5 = Utf8               age
```

类型为 Utf8，UTF-8 编码的字符串，值为 `age`，表明字段名为 age。

第 6 个常量：



```text
#6 = Utf8               I
```

类型为 Utf8，UTF-8 编码的字符串，值为 `I`，表明字段的类型为 int。

关于字段类型的描述符映射表如下图所示。

![img](images\bytecode-cbf16ce9-7853-4050-a1c0-8b874f3b0c1e.png)

到此为止，第 2 个常量算是摸完了。组合起来的意思就是，声明了一个类型为 int 的字段 age。

------

## [#](https://tobebetterjavaer.com/jvm/bytecode.html#_04、字段表集合)字段表集合

字段表用来描述接口或者类中声明的变量，包括类变量和成员变量，但不包含声明在方法中局部变量。

字段的修饰符一般有：

- 访问权限修饰符，比如 public private protected
- 静态变量修饰符，比如 static
- final 修饰符
- 并发可见性修饰符，比如 volatile
- 序列化修饰符，比如 transient

然后是字段的类型（可以是基本数据类型、数组和对象）和名称。

在 Main.class 字节码文件中，字段表的信息如下所示。



```text
private int age;
    descriptor: I
    flags: (0x0002) ACC_PRIVATE
```

表明字段的访问权限修饰符为 private，类型为 int，名称为 age。

字段的访问标志和类的访问标志非常类似。

![img](images\bytecode-5f328e11-3486-4eb4-8fa9-5c5febfab894.png)

## [#](https://tobebetterjavaer.com/jvm/bytecode.html#_05、方法表集合)**方法表集合**

方法表用来描述接口或者类中声明的方法，包括类方法和成员方法，以及构造方法。方法的修饰符和字段略有不同，比如说 volatile 和 transient 不能用来修饰方法，再比如说方法的修饰符多了 synchronized、native、strictfp 和 abstract。

![img](images\bytecode-fd434d5c-ffc6-4a24-9787-98e573035068.png)

下面这部分为构造方法，返回类型为 void，访问标志为 public。

```text
  public com.itwanger.jvm.Main();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
```

来详细看一下其中 Code 属性。

```text
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: bipush        18
         7: putfield      #2                  // Field age:I
        10: return
      LineNumberTable:
        line 6: 0
        line 7: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lcom/itwanger/jvm/Main;
```

- stack 为最大操作数栈，Java 虚拟机在运行的时候会根据这个值来分配栈帧的操作数栈深度。
- locals 为局部变量所需要的存储空间，单位为槽（slot），方法的参数变量和方法内的局部变量都会存储在局部变量表中。
- args_size 为方法的参数个数。

为什么 stack 的值为 2，locals 的值为 1，args_size 的值为 1 呢？ 默认的构造方法不是没有参数和局部变量吗？

这是因为有一个隐藏的 this 变量，只要不是静态方法，都会有一个当前类的对象 this 悄悄的存在着。这就解释了为什么 locals 和 args_size 的值为 1 的问题。那为什么 stack 的值为 2 呢？因为字节码指令 invokespecial（调用父类的构造方法进行初始化）会消耗掉一个当前类的引用，所以 aload_0 执行了 2 次，也就意味着操作数栈的大小为 2。

关于字节码指令，我们后面再详细介绍。

- LineNumberTable，该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。
- LocalVariableTable，该属性的作用是描述帧栈中的局部变量与源码中定义的变量之间的关系。大家仔细看一下，就能看到 this 的影子了。

下面这部分为成员方法 `getAge()`，返回类型为 int，访问标志为 public。



```text
  public int getAge();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
```

理解了构造方法的 Code 属性后，再看 `getAge()` 方法的 Code 属性时，就很容易理解了。



```text
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field age:I
         4: ireturn
      LineNumberTable:
        line 9: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/itwanger/jvm/Main;
```

最大操作数栈为 1，局部变量所需要的存储空间为 1，方法的参数个数为 1，是因为局部变量只有一个隐藏的 this，并且字节码指令中只执行了一次 aload_0。

------

其实学习是这样的，可以横向扩展，也可以纵向扩展。当我们初学编程的时候，特别想多学一点，属于横向扩展，当有了一定的编程经验后，想更上一层楼，就需要纵向扩展，不断深入地学，连根拔起，从而形成自己的知识体系。

无论是从十六进制的字节码角度，还是 jclasslib 图形化查看反编译后的字节码的角度，也或者是今天这样从 javap 反编译后的角度，都能窥探出一些新的内容来！

初学者一开始接触字节码的时候会感觉比较头大，没关系，我当初也是这样，随着时间的推移，经验的积累，慢慢就好了，越往深处钻，就越能体会到那种“技术我有，雄霸天下”的感觉~

# JVM字节码指令详解

大家好，我是二哥呀。Java 字节码指令是 JVM 体系中非常难啃的一块硬骨头，我估计有些读者会有这样的疑惑，“Java 字节码难学吗？我能不能学会啊？”

讲良心话，不是我谦虚，一开始学 Java 字节码和 Java 虚拟机方面的知识我也感觉头大！但硬着头皮学了一阵子之后，突然就开窍了，觉得好有意思，尤其是明白了 Java 代码在底层竟然是这样执行的时候，感觉既膨胀又飘飘然，浑身上下散发着自信的光芒！

Java 官方的虚拟机 Hotspot 是基于栈的，而不是基于寄存器的。

基于栈的优点是可移植性更好、指令更短、实现起来简单，但不能随机访问栈中的元素，完成相同功能所需要的指令数也比寄存器的要多，需要频繁的入栈和出栈。

基于寄存器的优点是速度快，有利于程序运行速度的优化，但操作数需要显式指定，指令也比较长。

Java 字节码由操作码和操作数组成。

- 操作码（Opcode）：一个字节长度（0-255，意味着指令集的操作码总数不可能超过 256 条），代表着某种特定的操作含义。
- 操作数（Operands）：零个或者多个，紧跟在操作码之后，代表此操作需要的参数。

由于 Java 虚拟机是基于栈而不是寄存器的结构，所以大多数指令都只有一个操作码。比如 `aload_0`（将局部变量表中下标为 0 的数据压入操作数栈中）就只有操作码没有操作数，而 `invokespecial #1`（调用成员方法或者构造方法，并传递常量池中下标为 1 的常量）就是由操作码和操作数组成的。

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_01、加载与存储指令)01、加载与存储指令

加载（load）和存储（store）相关的指令是使用最频繁的指令，用于将数据从栈帧的局部变量表和操作数栈之间来回传递。

**1）将局部变量表中的变量压入操作数栈中**

- `xload_<n>`（x 为 i、l、f、d、a，n 默认为 0 到 3），表示将第 n 个局部变量压入操作数栈中。
- xload（x 为 i、l、f、d、a），通过指定参数的形式，将局部变量压入操作数栈中，当使用这个指令时，表示局部变量的数量可能超过了 4 个

解释一下。

x 为操作码助记符，表明是哪一种数据类型。见下表所示。

![img](images\zijiema-zhiling-879da2f2-fb72-48a9-985e-5a28a9fc8814.png)

像 arraylength 指令，没有操作码助记符，它没有代表数据类型的特殊字符，但操作数只能是一个数组类型的对象。

大部分的指令都不支持 byte、short 和 char，甚至没有任何指令支持 boolean 类型。编译器会将 byte 和 short 类型的数据带符号扩展（Sign-Extend）为 int 类型，将 boolean 和 char 零位扩展（Zero-Extend）为 int 类型。

举例来说。



```java
private void load(int age, String name, long birthday, boolean sex) {
    System.out.println(age + name + birthday + sex);
}
```

通过 jclasslib 看一下 `load()` 方法（4 个参数）的字节码指令。

![img](images\zijiema-zhiling-05bfae95-2a33-402c-9041-570093729c42.png)

- iload_1：将局部变量表中下标为 1 的 int 变量压入操作数栈中。
- aload_2：将局部变量表中下标为 2 的引用数据类型变量（此时为 String）压入操作数栈中。
- lload_3：将局部变量表中下标为 3 的 long 型变量压入操作数栈中。
- iload 5：将局部变量表中下标为 5 的 int 变量（实际为 boolean）压入操作数栈中。

通过查看局部变量表就能关联上了。

![img](images\zijiema-zhiling-79d74946-ce9e-41d4-b889-bda861f847bc.png)

**2）将常量池中的常量压入操作数栈中**

根据数据类型和入栈内容的不同，此类又可以细分为 const 系列、push 系列和 Idc 指令。

**const 系列**，用于特殊的常量入栈，要入栈的常量隐含在指令本身。

![img](images\zijiema-zhiling-270c314d-872b-43b0-861f-417eafc046fd.png)

**push 系列**，主要包括 bipush 和 sipush，前者接收 8 位整数作为参数，后者接收 16 位整数。

**Idc 指令**，当 const 和 push 不能满足的时候，万能的 Idc 指令就上场了，它接收一个 8 位的参数，指向常量池中的索引。

- `Idc_w`：接收两个 8 位数，索引范围更大。
- 如果参数是 long 或者 double，使用 `Idc2_w` 指令。

举例来说。



```java
public void pushConstLdc() {
    // 范围 [-1,5]
    int iconst = -1;
    // 范围 [-128,127]
    int bipush = 127;
    // 范围 [-32768,32767]
    int sipush= 32767;
    // 其他 int
    int ldc = 32768;
    String aconst = null;
    String IdcString = "沉默王二";
}
```

通过 jclasslib 看一下 `pushConstLdc()` 方法的字节码指令。

![img](images\zijiema-zhiling-b34fc802-18bb-46a1-8d24-de2087c9b6bf.png)

- iconst_m1：将 -1 入栈。范围 [-1,5]。
- bipush 127：将 127 入栈。范围 [-128,127]。
- sipush 32767：将 32767 入栈。范围 [-32768,32767]。
- ldc #6 <32768>：将常量池中下标为 6 的常量 32768 入栈。
- aconst_null：将 null 入栈。
- ldc #7 <沉默王二>：将常量池中下标为 7 的常量“沉默王二”入栈。

**3）将栈顶的数据出栈并装入局部变量表中**

主要是用来给局部变量赋值，这类指令主要以 store 的形式存在。

- `xstore_<n>`（x 为 i、l、f、d、a，n 默认为 0 到 3）
- xstore（x 为 i、l、f、d、a）

明白了 `xload_<n>` 和 xload，再看 `xstore_<n>` 和 xstore 就会轻松得多，作用反了一下而已。

大家来想一个问题，为什么要有 `xstore_<n>` 和 `xload_<n>` 呢？它们的作用和 xstore n、xload n 不是一样的吗？

`xstore_<n>` 和 xstore n 的区别在于，前者相当于只有操作码，占用 1 个字节；后者相当于由操作码和操作数组成，操作码占 1 个字节，操作数占 2 个字节，一共占 3 个字节。

由于局部变量表中前几个位置总是非常常用，虽然 `xstore_<n>` 和 `xload_<n>` 增加了指令数量，但字节码的体积变小了！

举例来说。



```java
public void store(int age, String name) {
    int temp = age + 2;
    String str = name;
}
```

通过 jclasslib 看一下 `store()` 方法的字节码指令。

![img](images\zijiema-zhiling-d955468c-d07d-47cd-b82b-c03ecea8753d.png)

- istore_3：从操作数中弹出一个整数，并把它赋值给局部变量表中索引为 3 的变量。
- astore 4：从操作数中弹出一个引用数据类型，并把它赋值给局部变量表中索引为 4 的变量。

通过查看局部变量表就能关联上了。

![img](images\zijiema-zhiling-a08c20cb-c148-47c9-91e2-df37e68989a9.png)

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_02、算术指令)02、算术指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。可以分为两类：整型数据的运算指令和浮点数据的运算指令。

需要注意的是，**数据运算可能会导致溢出**，比如两个很大的正整数相加，很可能会得到一个负数。但 Java 虚拟机规范中并没有对这种情况给出具体结果，因此程序是不会显式报错的。所以，大家在开发过程中，如果涉及到较大的数据进行加法、乘法运算的时候，一定要注意！

当发生溢出时，将会使用有符号的无穷大 Infinity 来表示；如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 作为操作数的算术操作，结果都会返回 NaN。

举例来说。



```java
public void infinityNaN() {
    int i = 10;
    double j = i / 0.0;
    System.out.println(j); // Infinity

    double d1 = 0.0;
    double d2 = d1 / 0.0;
    System.out.println(d2); // NaN
}
```

- 任何一个非零的数除以浮点数 0（注意不是 int 类型），可以想象结果是无穷大 Infinity 的。
- 把这个非零的数换成 0 的时候，结果又不太好定义，就用 NaN 值来表示。

Java 虚拟机提供了两种**运算模式**：

- 向最接近数舍入：在进行浮点数运算时，所有的结果都必须舍入到一个适当的精度，不是特别精确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值接近，将优先选择最低有效位为零的（类似四舍五入）。
- 向零舍入：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果（类似取整）。

我把所有的算术指令列一下：

- 加法指令：iadd、ladd、fadd、dadd
- 减法指令：isub、lsub、fsub、dsub
- 乘法指令：imul、lmul、fmul、dmul
- 除法指令：idiv、ldiv、fdiv、ddiv
- 求余指令：irem、lrem、frem、drem
- 自增指令：iinc

举例来说。



```java
public void calculate(int age) {
    int add = age + 1;
    int sub = age - 1;
    int mul = age * 2;
    int div = age / 3;
    int rem = age % 4;
    age++;
    age--;
}
```

通过 jclasslib 看一下 `calculate()` 方法的字节码指令。

![img](images\zijiema-zhiling-598e4204-fd77-425b-b536-1e001cda8e13.png)

- iadd，加法
- isub，减法
- imul，乘法
- idiv，除法
- irem，取余
- iinc，自增的时候 +1，自减的时候 -1

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_03、类型转换指令)03、类型转换指令

可以分为两种：

1）宽化，小类型向大类型转换，比如 `int–>long–>float–>double`，对应的指令有：i2l、i2f、i2d、l2f、l2d、f2d。

- 从 int 到 long，或者从 int 到 double，是不会有精度丢失的；
- 从 int、long 到 float，或者 long 到 double 时，可能会发生精度丢失；
- 从 byte、char 和 short 到 int 的宽化类型转换实际上是隐式发生的，这样可以减少字节码指令，毕竟字节码指令只有 256 个，占一个字节。

2）窄化，大类型向小类型转换，比如从 int 类型到 byte、short 或者 char，对应的指令有：i2b、i2s、i2c；从 long 到 int，对应的指令有：l2i；从 float 到 int 或者 long，对应的指令有：f2i、f2l；从 double 到 int、long 或者 float，对应的指令有：d2i、d2l、d2f。

- 窄化很可能会发生精度丢失，毕竟是不同的数量级；
- 但 Java 虚拟机并不会因此抛出运行时异常。

举例来说。



```java
public void updown() {
    int i = 10;
    double d = i;
    
    float f = 10f;
    long ong = (long)f;
}
```

通过 jclasslib 看一下 `updown()` 方法的字节码指令。

![img](images\zijiema-zhiling-0c3e47c6-1e25-4926-a838-20cf146a8993.png)

- i2d，int 宽化为 double
- f2l， float 窄化为 long

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_04、对象的创建和访问指令)04、对象的创建和访问指令

Java 是一门面向对象的编程语言，那么 Java 虚拟机是如何从字节码层面进行支持的呢？

**1）创建指令**

数组也是一种对象，但它创建的字节码指令和普通的对象不同。创建数组的指令有三种：

- newarray：创建基本数据类型的数组
- anewarray：创建引用类型的数组
- multianewarray：创建多维数组

普通对象的创建指令只有一个，就是 `new`，它会接收一个操作数，指向常量池中的一个索引，表示要创建的类型。

举例来说。



```java
public void newObject() {
    String name = new String("沉默王二");
    File file = new File("无愁河的浪荡汉子.book");
    int [] ages = {};
}
```

通过 jclasslib 看一下 `newObject()` 方法的字节码指令。

![img](images\zijiema-zhiling-8125da3d-876c-43fe-8347-cb2341408088.png)

- `new #13 <java/lang/String>`，创建一个 String 对象。
- `new #15 <java/io/File>`，创建一个 File 对象。
- `newarray 10 (int)`，创建一个 int 类型的数组。

**2）字段访问指令**

字段可以分为两类，一类是成员变量，一类是静态变量（static 关键字修饰的），所以字段访问指令可以分为两类：

- 访问静态变量：getstatic、putstatic。
- 访问成员变量：getfield、putfield，需要创建对象后才能访问。

举例来说。



```java
public class Writer {
    private String name;
    static String mark = "作者";

    public static void main(String[] args) {
        print(mark);
        Writer w = new Writer();
        print(w.name);
    }

    public static void print(String arg) {
        System.out.println(arg);
    }
}
```

通过 jclasslib 看一下 `main()` 方法的字节码指令。

![img](images\zijiema-zhiling-70441cfc-7c6e-4a5e-b0dd-818fc3fa1a67.png)

- `getstatic #2 <com/itwanger/jvm/Writer.mark>`，访问静态变量 mark
- `getfield #6 <com/itwanger/jvm/Writer.name>`，访问成员变量 name

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_05、方法调用和返回指令)05、方法调用和返回指令

方法调用指令有 5 个，分别用于不同的场景：

- invokevirtual：用于调用对象的成员方法，根据对象的实际类型进行分派，支持多态。
- invokeinterface：用于调用接口方法，会在运行时搜索由特定对象实现的接口方法进行调用。
- invokespecial：用于调用一些需要特殊处理的方法，包括构造方法、私有方法和父类方法。
- invokestatic：用于调用静态方法。
- invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行。

举例来说。



```java
public class InvokeExamples {
    private void run() {
        List ls = new ArrayList();
        ls.add("难顶");

        ArrayList als = new ArrayList();
        als.add("学不动了");
    }

    public static void print() {
        System.out.println("invokestatic");
    }

    public static void main(String[] args) {
        print();
        InvokeExamples invoke = new InvokeExamples();
        invoke.run();
    }
}
```

我们用 `javap -c InvokeExamples.class` 来反编译一下。



```text
Compiled from "InvokeExamples.java"
public class com.itwanger.jvm.InvokeExamples {
  public com.itwanger.jvm.InvokeExamples();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  private void run();
    Code:
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String 难顶
      11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
      16: pop
      17: new           #2                  // class java/util/ArrayList
      20: dup
      21: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
      24: astore_2
      25: aload_2
      26: ldc           #6                  // String 学不动了
      28: invokevirtual #7                  // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z
      31: pop
      32: return

  public static void print();
    Code:
       0: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #9                  // String invokestatic
       5: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return

  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #11                 // Method print:()V
       3: new           #12                 // class com/itwanger/jvm/InvokeExamples
       6: dup
       7: invokespecial #13                 // Method "<init>":()V
      10: astore_1
      11: aload_1
      12: invokevirtual #14                 // Method run:()V
      15: return
}
```

InvokeExamples 类有 4 个方法，包括缺省的构造方法在内。

1）`InvokeExamples()` 构造方法中

缺省的构造方法内部会调用超类 Object 的初始化构造方法：



```text
`invokespecial #1 // Method java/lang/Object."<init>":()V`
```

2）成员方法 `run()` 中



```text
invokeinterface #5,  2  // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
```

由于 ls 变量的引用类型为接口 List，所以 `ls.add()` 调用的是 `invokeinterface` 指令，等运行时再确定是不是接口 List 的实现对象 ArrayList 的 `add()` 方法。



```text
invokevirtual #7 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z
```

由于 als 变量的引用类型已经确定为 ArrayList，所以 `als.add()` 方法调用的是 `invokevirtual` 指令。

3）`main()` 方法中



```text
invokestatic  #11 // Method print:()V
```

`print()` 方法是静态的，所以调用的是 `invokestatic` 指令。

方法返回指令根据方法的返回值类型进行区分，常见的返回指令见下图。

![img](images\zijiema-zhiling-37513fa2-fdba-45db-adfc-c18225c6ff8b.png)

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_06、操作数栈管理指令)06、操作数栈管理指令

常见的操作数栈管理指令有 pop、dup 和 swap。

- 将一个或两个元素从栈顶弹出，并且直接废弃，比如 pop，pop2；
- 复制栈顶的一个或两个数值并将其重新压入栈顶，比如 dup，dup2，dup_×1，dup2_×1，dup_×2，dup2_×2；
- 将栈最顶端的两个槽中的数值交换位置，比如 swap。

这些指令不需要指明数据类型，因为是按照位置压入和弹出的。

举例来说。



```java
public class Dup {
    int age;
    public int incAndGet() {
        return ++age;
    }
}
```

通过 jclasslib 看一下 `incAndGet()` 方法的字节码指令。

![img](images\zijiema-zhiling-642ca54e-5808-428d-9840-ebf478e95c17.png)

- aload_0：将 this 入栈。
- dup：复制栈顶的 this。
- getfield #2：将常量池中下标为 2 的常量加载到栈上，同时将一个 this 出栈。
- iconst_1：将常量 1 入栈。
- iadd：将栈顶的两个值相加后出栈，并将结果放回栈上。
- dup_x1：复制栈顶的元素，并将其插入 this 下面。
- putfield #2： 将栈顶的两个元素出栈，并将其赋值给字段 age。
- ireturn：将栈顶的元素出栈返回。

## [#](https://tobebetterjavaer.com/jvm/zijiema-zhiling.html#_07、控制转移指令)07、控制转移指令

控制转移指令包括：

- 比较指令，比较栈顶的两个元素的大小，并将比较结果入栈。
- 条件跳转指令，通常和比较指令一块使用，在条件跳转指令执行前，一般先用比较指令进行栈顶元素的比较，然后进行条件跳转。
- 比较条件转指令，类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。
- 多条件分支跳转指令，专为 switch-case 语句设计的。
- 无条件跳转指令，目前主要是 goto 指令。

**1）比较指令**

比较指令有：dcmpg，dcmpl、fcmpg、fcmpl、lcmp，指令的第一个字母代表的含义分别是 double、float、long。注意，没有 int 类型。

对于 double 和 float 来说，由于 NaN 的存在，有两个版本的比较指令。拿 float 来说，有 fcmpg 和 fcmpl，区别在于，如果遇到 NaN，fcmpg 会将 1 压入栈，fcmpl 会将 -1 压入栈。

举例来说。



```java
public void lcmp(long a, long b) {
    if(a > b){}
}
```

通过 jclasslib 看一下 `lcmp()` 方法的字节码指令。

![img](images\zijiema-zhiling-e8fa6685-b3d4-4f42-8fc5-8a4d8a9efe7b.png)

lcmp 用于两个 long 型的数据进行比较。

**2）条件跳转指令**

![img](images\zijiema-zhiling-5de34f26-52ad-4e07-a20d-91ea92038984.png)

这些指令都会接收两个字节的操作数，它们的统一含义是，弹出栈顶元素，测试它是否满足某一条件，满足的话，跳转到对应位置。

对于 long、float 和 double 类型的条件分支比较，会先执行比较指令返回一个整型值到操作数栈中后再执行 int 类型的条件跳转指令。

对于 boolean、byte、char、short，以及 int，则直接使用条件跳转指令来完成。

举例来说。



```java
public void fi() {
    int a = 0;
    if (a == 0) {
        a = 10;
    } else {
        a = 20;
    }
}
```

通过 jclasslib 看一下 `fi()` 方法的字节码指令。

![img](images\zijiema-zhiling-d0561d5c-ae21-48e7-9e7c-4aae87d02f56.png)

`3 ifne 12 (+9)` 的意思是，如果栈顶的元素不等于 0，跳转到第 12（3+9）行 `12 bipush 20`。

**3）比较条件转指令**

![img](images\zijiema-zhiling-bfab6edd-d63f-45a7-8838-997e7630fa2a.png)

前缀“if_”后，以字符“i”开头的指令针对 int 型整数进行操作，以字符“a”开头的指令表示对象的比较。

举例来说。



```java
public void compare() {
    int i = 10;
    int j = 20;
    System.out.println(i > j);
}
```

通过 jclasslib 看一下 `compare()` 方法的字节码指令。

![img](images\zijiema-zhiling-d4f9a680-1364-4af9-9474-c0763c9bc6f7.png)

`11 if_icmple 18 (+7)` 的意思是，如果栈顶的两个 int 类型的数值比较的话，如果前者小于后者时跳转到第 18 行（11+7）。

**4）多条件分支跳转指令**

主要有 tableswitch 和 lookupswitch，前者要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高；后者内部存放着各个离散的 case-offset 对，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低。

举例来说。



```java
public void switchTest(int select) {
    int num;
    switch (select) {
        case 1:
            num = 10;
            break;
        case 2:
        case 3:
            num = 30;
            break;
        default:
            num = 40;
    }
}
```

通过 jclasslib 看一下 `switchTest()` 方法的字节码指令。

![img](images\zijiema-zhiling-04e166ae-13c7-4025-804a-be88e2923a50.png)

case 2 的时候没有 break，所以 case 2 和 case 3 是连续的，用的是 tableswitch。如果等于 1，跳转到 28 行；如果等于 2 和 3，跳转到 34 行，如果是 default，跳转到 40 行。

**5）无条件跳转指令**

goto 指令接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。

前面的例子里都出现了 goto 的身影，也很好理解。如果指令的偏移量特别大，超出了两个字节的范围，可以使用指令 goto_w，接收 4 个字节的操作数。

------

更多指令，可以阅读下面这篇文章：

> https://segmentfault.com/a/1190000037628881

> 路漫漫其修远兮，吾将上下而求索

想要走得更远，Java 字节码这块就必须得硬碰硬地吃透，希望二哥的这些分享可以帮助到大家~

# ASM

##  前言

ASM是一种通用Java字节码操作和分析框架。它可以用于修改现有的class文件或动态生成class文件。

> **ASM **is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form. ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. ASM offers similar functionality as other Java bytecode frameworks, but is focused on[performanceopen in new window](https://asm.ow2.io/performance.html). Because it was designed and implemented to be as small and as fast as possible, it is well suited for use in dynamic systems (but can of course be used in a static way too, e.g. in compilers).

本篇文章分享的是对ASM的理解和应用，之前需要我们掌握**class字节码**，**JVM基于栈的设计模式,JVM指令**

## [#](https://tobebetterjavaer.com/jvm/asm.html#class字节码)class字节码

我们编写的java文件，会通过javac命令编译为class文件，JVM最终会执行该类型文件来运行程序。下图所示为class文件结构。

![img](images\asm-43844b78-c01f-4990-b038-3c91ff2eeb34.jpg)

下面我们通过一个简单的实例来进行说明。下面是我们编写的一个简单的java文件，只是简单的函数调用.



```java
public class Test {
    private int num1 = 1;
    public static int NUM1 = 100;
    public int func(int a,int b){
        return add(a,b);
    }
    public int add(int a,int b) {
        return a+b+num1;
    }
    public int sub(int a, int b) {
        return a-b-NUM1;
    }
}
```

使用javac -g Test.java编译为class文件，然后通过 `javap -verbose Test.class` 命令查看class文件格式。



```text
public class com.wuba.asmdemo.Test
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#26         // java/lang/Object."<init>":()V
   #2 = Fieldref           #5.#27         // com/wuba/asmdemo/Test.num1:I
   #3 = Methodref          #5.#28         // com/wuba/asmdemo/Test.add:(II)I
   #4 = Fieldref           #5.#29         // com/wuba/asmdemo/Test.NUM1:I
   #5 = Class              #30            // com/wuba/asmdemo/Test
   #6 = Class              #31            // java/lang/Object
   #7 = Utf8               num1
   #8 = Utf8               I
   #9 = Utf8               NUM1
  #10 = Utf8               <init>
  #11 = Utf8               ()V
  #12 = Utf8               Code
  #13 = Utf8               LineNumberTable
  #14 = Utf8               LocalVariableTable
  #15 = Utf8               this
  #16 = Utf8               Lcom/wuba/asmdemo/Test;
  #17 = Utf8               func
  #18 = Utf8               (II)I
  #19 = Utf8               a
  #20 = Utf8               b
  #21 = Utf8               add
  #22 = Utf8               sub
  #23 = Utf8               <clinit>
  #24 = Utf8               SourceFile
  #25 = Utf8               Test.java
  #26 = NameAndType        #10:#11        // "<init>":()V
  #27 = NameAndType        #7:#8          // num1:I
  #28 = NameAndType        #21:#18        // add:(II)I
  #29 = NameAndType        #9:#8          // NUM1:I
  #30 = Utf8               com/wuba/asmdemo/Test
  #31 = Utf8               java/lang/Object
{
  public static int NUM1;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC

  public com.wuba.asmdemo.Test();     //构造函数
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iconst_1
         6: putfield      #2                  // Field num1:I
         9: return
      LineNumberTable:
        line 3: 0
        line 5: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lcom/wuba/asmdemo/Test;

  public int func(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=3, args_size=3
         0: aload_0
         1: iload_1
         2: iload_2
         3: invokevirtual #3                  // Method add:(II)I
         6: ireturn
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       7     0  this   Lcom/wuba/asmdemo/Test;
            0       7     1     a   I
            0       7     2     b   I

  public int add(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: iload_2
         2: iadd
         3: aload_0
         4: getfield      #2                  // Field num1:I
         7: iadd
         8: ireturn
      LineNumberTable:
        line 14: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/wuba/asmdemo/Test;
            0       9     1     a   I
            0       9     2     b   I

  public int sub(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: iload_2
         2: isub
         3: getstatic     #4                  // Field NUM1:I
         6: isub
         7: ireturn
      LineNumberTable:
        line 18: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       8     0  this   Lcom/wuba/asmdemo/Test;
            0       8     1     a   I
            0       8     2     b   I

  static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: bipush        100
         2: putstatic     #4                  // Field NUM1:I
         5: return
      LineNumberTable:
        line 7: 0
}
SourceFile: "Test.java"
```

可以看出在编译为class文件后，字段名称，方法名称，类型名称等均在常量池中存在的。从而做到减小文件的目的。同时方法定义也转变为了jvm指令。下面我们需要对jvm指令加深一下了解。在了解之前需要我们理解JVM基于栈的设计模式

## [#](https://tobebetterjavaer.com/jvm/asm.html#jvm基于栈的设计模式)JVM基于栈的设计模式

JVM的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性。在线程中执行一个方法时，我们会创建一个栈帧入栈并执行，如果该方法又调用另一个方法时会再次创建新的栈帧然后入栈，方法返回之际，原栈帧会返回方法的执行结果给之前的栈帧，随后虚拟机将会丢弃此栈帧。

![img](images\asm-e31b7e50-1d48-4eef-9552-6fa7e6c68fed.jpg)

### [#](https://tobebetterjavaer.com/jvm/asm.html#局部变量表)局部变量表

**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。虚拟机通过索引定位的方法查找相应的局部变量。举个例子。以上述的代码为例



```java
 public int sub(int a, int b) {
        return a-b-NUM1;
    }
```

这个方法大家可以猜测一下局部变量有哪些? 答案是3个，不应该只有a,b吗？还有this,对应实例对象方法编译器都会追加一个this参数。如果该方法为静态方法则为2个了。



```text
public int sub(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: iload_2
         2: isub
         3: getstatic     #4                  // Field NUM1:I
         6: isub
         7: ireturn
      LineNumberTable:
        line 18: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       8     0  this   Lcom/wuba/asmdemo/Test;
            0       8     1     a   I
            0       8     2     b   I
```

所以局部变量表第0个元素为this, 第一个为a,第二个为b

### [#](https://tobebetterjavaer.com/jvm/asm.html#操作数栈)操作数栈

通过局部变量表我们有了要操作和待更新的数据，我们如果对局部变量这些数据进行操作呢？通过操作数栈。当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。

### [#](https://tobebetterjavaer.com/jvm/asm.html#jvm指令)JVM指令

- load 命令：用于将局部变量表的指定位置的相应类型变量加载到操作数栈顶；
- store命令：用于将操作数栈顶的相应类型数据保入局部变量表的指定位置；
- invokevirtual:调用实例方法
- ireturn: 当前方法返回int

**再举个例子**

a = b + c 的字节码执行过程中操作数栈以及局部变量表的变化如下图所示

![img](images\asm-4670450e-6199-4562-9cf4-354234c734c8.jpg)

![img](images\asm-9808d639-327f-4796-80d4-1809be0b9106.jpg)

## [#](https://tobebetterjavaer.com/jvm/asm.html#asm操作)ASM操作

通过上面的介绍，我们对字节码和JVM指令有了进一步的了解，下面我们看一下ASM是如果编辑class字节码的。

## [#](https://tobebetterjavaer.com/jvm/asm.html#asm-api)ASM API

ASM API基于访问者模式，为我们提供了ClassVisitor，MethodVisitor，FieldVisitor API接口，每当ASM扫描到类字段是会回调visitField方法，扫描到类方法是会回调MethodVisitor，下面我们看一下API接口

**ClassVisitor方法解析**

```java
public abstract class ClassVisitor {
        ......
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces);
    //访问类字段时回调
    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value);
    //访问类方法是回调
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions);
    public void visitEnd();
}
```

## [#](https://tobebetterjavaer.com/jvm/asm.html#methodvisitor方法解析)MethodVisitor方法解析



```java
public abstract class MethodVisitor {
        ......
    public void visitParameter(String name, int access);
    //访问本地变量类型指令 操作码可以是LOAD,STORE，RET中一种；
    public void visitIntInsn(int opcode, int operand);
    //域操作指令，用来加载或者存储对象的Field
    public void visitFieldInsn(int opcode, String owner, String name, String descriptor);
    //访问方法操作指令
    public void visitMethodInsn(int opcode, String owner, String name, String descriptor);
    public void visitEnd();
}
```

### [#](https://tobebetterjavaer.com/jvm/asm.html#asm-使用demo)ASM 使用Demo

java源码

```java
 public int add(int a,int b) {
        return a+b+num1;
 }
```

class字节码

```text
 public int add(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: iload_1
         1: iload_2
         2: iadd
         3: aload_0
         4: getfield      #2                  // Field num1:I
         7: iadd
         8: ireturn
      LineNumberTable:
        line 14: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/wuba/asmdemo/Test;
            0       9     1     a   I
            0       9     2     b   I
```

ASM对应的API

```text
mv = cw.visitMethod(ACC_PUBLIC, "add", "(II)I", null, null);
mv.visitCode();
mv.visitVarInsn(ILOAD, 1);
mv.visitVarInsn(ILOAD, 2);
mv.visitInsn(IADD);
mv.visitVarInsn(ALOAD, 0);
mv.visitFieldInsn(GETFIELD, "com/wuba/asmdemo/Test", "num1", "I");
mv.visitInsn(IADD);
mv.visitInsn(IRETURN);
Label l1 = new Label();
mv.visitLabel(l1);
mv.visitLocalVariable("this", "Lcom/wuba/asmdemo/Test;", null, l0, l1, 0);
mv.visitLocalVariable("a", "I", null, l0, l1, 1);
mv.visitLocalVariable("b", "I", null, l0, l1, 2);
mv.visitMaxs(2, 3);
mv.visitEnd();
```

可以看出ASM是在指令层次上操作字节码的，和class字节码更加接近。如果我们有些字节码操作的需求，ASM一定可以实现的。只是使用起来比较麻烦一些。这里强烈推荐一款ASM插件

> https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline

可以一键生成对应的ASM API代码

![img](images\asm-3c8c8db4-5b6a-4576-b147-62965d0e0c1c.jpg)

------

> 参考链接：https://zhuanlan.zhihu.com/p/94498015