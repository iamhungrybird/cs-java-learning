# 前言

不管用哪种语言进行编码，我们总是需要对我们的代码进行测试。测试的种类很多，包括集成测试、冒烟测试、单元测试、压力测试、回归测试等等。在这些测试方式中，程序员直面的一定是单元测试。

# 一、概述

## 1.1 单元测试是什么？

单元测试，英文名为 Unit Testing，顾名思义就是对一个个代码单元进行测试。所谓单元，就是一个个小的代码块。在 Java 中，最小的可测试单元其实是类下面的方法。理想中的单元测试通常是基于类的方法而进行的测试，其目的在于测试方法的逻辑是否符合我们的预期。

## 1.2 为什么要写单元测试？

实际工作中，我们经常会遇到一些问题。

1. 业务场景很复杂，代码逻辑也同样复杂。
2. 改动老代码牵涉面太多，担心改出问题。
3. 一旦想好了如何改代码，几分钟就能完成编码，但是测试却要花好几个小时。
4. 已经写好了的单元测试，老是一会儿成功一会儿又失败，稳定性很差。

造成这些问题的原因，往往是因为我们的业务代码不能被单元测试代码覆盖（cover）住。说得直白点，就是代码的健壮性不够好。因此，我们需要写好单元测试，写好之后能得到以下好处。

1. 单元测试能够让我们放心地修改和重构代码。
2. 单元测试执行通过之后，我们可以认为我们的代码就是正确的了，增强了自信心。
3. 单元测试能提高代码覆盖率，领导看得见。

## 1.3 BCDE原则

在《阿里巴巴Java开发手册》中，有一条是讲 BCDE 原则的，我觉得很有道理。

```
【强制】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。

B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
C：Correct，正确的输入，并得到预期的结果。
D：Design，与设计文档相结合，来编写单元测试。
E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得
到预期的结果。
```

## 1.4 given-when-then模板

好的单元测试有一个特点就是易写。同时，单元测试作为业务访问的入口，还需要做到易读。我们对单元测试编写的过程进行归纳抽象，大致有 3 个过程：

1. given（准备数据）。需要准备好用例执行需要的环境，包括：mock对象、mock对象的mock过程及返回值、请求参数等。
2. when（执行）。执行被测试的方法。
3. then（校验）。校验执行过程和执行结果。

这 3 个过程的示意图如下：

![](images/9-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

given-when-then示意图

我们编写的测试代码，可以参考下面的模板：

```
@Test
public void getUsernameById_when_fetch_user() {
    // given 
    final Long id = 1L;
    final String mockedUsername = "zhangsan";
    Mockito.when(userMapper.getById(id)).thenReturn(new User().setId(id).setUsername(mockedUsername));

    // when
    String dbUsername = userService.getUsernameById(id);

    // then
    Assert.assertEquals(mockedUsername, dbUsername);
}
```

# 二、Junit

在 Java 领域，一般使用 junit 作为测试框架。

## 2.1 Maven 依赖

首先、我们引入 junit 依赖。依赖的版本可根据实际情况进行调整，楼主使用的版本为：4.13.1。

```
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

## 2.2 核心概念及生命周期

junit 中有几个核心概念，需要提前说明一下。

1. 测试类。包含一个或多个测试方法的 `*Test.java` 文件。
2. 测试方法。使用 `@Test` 注解修饰的方法。
3. 测试套件。专业术语叫 `suite`，可以包含多个测试类。
4. 测试运行器。使用什么方式去运行测试类、测试方法或测试套件。通常使用 `@RunWith` 进行指定，默认为 `org.junit.runners.JUnit4`。

为了实现单元测试，我们需要了解一些常用的注解。其中，2 -> 7 的注解作用于生命周期中的各个环节。

1. @RunWith
2. @Test
3. @BeforeClass
4. @AfterClass
5. @Before
6. @After
7. @Ignore

生命周期示例图如下：

![图片](images/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)

生命周期示意图

#### 2.2.1 @RunWith

通常用于修饰测试类。在不指定的情况下，默认的运行器为 `org.junit.runners.JUnit4`。当测试类被 `@RunWith` 注解修饰时，或者测试类继承了一个被该注解修饰的类，junit 将会使用这个注解所指明的运行器来运行单元测试，而不再使用 junit 默认的运行器。

```
@RunWith(JUnit4.class)
@RunWith(MockitoJUnitRunner.class)
public class XxxTest {

    //...
}
```

#### 2.2.2 @Test

junit3 是通过对测试类和测试方法的命名来确定是否为测试方法的。同时，所有的测试类必须继承 junit 的测试基类。

而在 junit4 中，只需要在方法上加上 `@Test` 注解，就可以将一个普通方法修饰为一个测试方法，可选参数包含：`timeout`、`excepted`。

1. 测试方法必须是 `public void`，即公共、无返回。

2. `@Test(timeout = 1000)`。被修饰的测试方法必须在预期时间内执行完成，否则测试失败。默认为 0，即：不设置超时。

3. `@Test(expected = NullPointerException.class)`

4. 1. 设置被修饰的测试方法应该抛出的预期异常，异常类型为：`NullPointerException.class`。
   2. 如果测试方法没有抛出预期异常，那么测试失败。假设抛出的异常为 `UnsupportedOperationException`，说明测试失败了。
   3. 如果抛出的异常类为指定异常类的子类，那么测试通过。

```
public class XxxTest {

    @Test(timeout = 1000, expected = NullPointerException.class)
    public void test() {
        // ...
    }
}
```

#### 2.2.3 @BeforeClass

用于修饰测试类中的非测试方法，该方法将在其所属测试类中的所有测试方法执行前运行，且只运行一次，可用于做一些测试准备工作，例如：连接数据库、打开或读取配置文件等。

【注】：`@BeforeClass` 修饰的方法必须是被 `public static void` 修饰的方法，即公共、静态、无返回。

#### 2.2.4 @AfterClass

和 `BeforeClass` 的作用相反，该注解用于修饰测试类中的非测试方法，该方法将在其所属测试类中所有测试方法执行完成后运行，且只运行一次，可用于做一些测试后的清理工作，例如：断开数据库连接，关闭配置文件等。

【注】：`@AfterClass` 修饰的方法必须是被 `public static void` 修饰的方法，即公共、静态、无返回。

#### 2.2.5 @Before

修饰测试类中的非测试方法，该方法会在其所属测试类中的每个测试方法执行前运行一次，主要用于为单个测试方法做一些基础的测试准备工作。

【注】：`@Before` 修饰的方法必须是被 `public void` 修饰的方法，即公共、无返回，但不能被 `static` 修饰。

#### 2.2.6 @After

修饰测试类中的非测试方法，和 `@Before` 相反，该方法会在其所属测试类中的每个测试方法执行完成后运行一次。

【注】：`@After` 修饰的方法必须是被 `public void` 修饰的方法，即公共、无返回，但不能被 `static`修饰。

#### 2.2.7 @Ignore

注释掉一个测试方法或一个类，被注释的类或方法不会被执行。但是，不建议经常这样做，容易忘记更新这些测试代码，导致代码不够干净，用例遗漏。

【注】：`@Ignore` 在继承的时候具备传递性。但是，子类可以通过 “重写” 的方式取消掉 “忽略” 特性。

```
public class BaseIgnoreTest {

    @Ignore
    @Test
    public void baseNotOverrideTest() {
        System.out.println("baseNotOverrideTest");
    }

    @Ignore
    @Test
    public void baseOverrideTest() {
        System.out.println("baseOverrideTest");
    }
}

public class ChildIgnoreTest extends BaseIgnoreTest {

    @Test
    public void childTest() {
        System.out.println("childTest");
    }

    @Test
    @Override
    public void baseOverrideTest() {
        System.out.println("child override test");
    }
}
```

执行情况如下所示：

```
【忽略】BaseIgnoreTest
    【忽略】BaseIgnoreTest.baseNotOverrideTest
    【忽略】BaseIgnoreTest.baseOverrideTest
【执行】ChildIgnoreTest
    【执行】ChildIgnoreTest.childTest
    【执行】ChildIgnoreTest.baseOverrideTest
    【忽略】ChildIgnoreTest.baseNotOverrideTest
```

#### 2.2.8 测试方法执行顺序

在测试类中，如果我们要指定方法的执行顺序，可以使用 `FixMethodOrder` 注解。这种方式可以保证测试方法不会乱序执行。示例代码如下：

```
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class MethodOrderTest {

    @Test
    public void testB() {
        System.out.println("second");
    }

    @Test
    public void testA() {
        System.out.println("first");
    }

    @Test
    public void testC() {
        System.out.println("third");
    }
}
```

`MethodSorter` 是一个枚举，包含以下枚举项，默认为 `DEFAULT`。

```
public enum MethodSorters {
    /**
     * 按照字母升序执行
     */
    NAME_ASCENDING(MethodSorter.NAME_ASCENDING),

    /**
     * 按照JVM中方法的加载顺序执行
     */
    JVM(null),

    /**
     * 默认顺序，由方法名的 “hashcode值” 决定，如果hash值大小一致，则按照名字的字典顺序排序。
     * 由于hashcode的生成和操作系统相关(以native修饰），所以对于不同操作系统，可能会出现不一样的执行顺序。
     * 在同一个操作系统上，多次执行的顺序不变。
     */
    DEFAULT(MethodSorter.DEFAULT);
}
```

#### 2.2.9 一个例子

在下面这个例子中，我们对上面提到的注解进行了验证，验证的结果也和我们的预期一致。测试代码如下：

```
@RunWith(MockitoJUnitRunner.class)
public class UserServiceImpl4AnnotationTest {

    @Mock
    private UserMapper userMapper;
    @InjectMocks
    private UserServiceImpl userService;

    @BeforeClass
    public static void beforeClass() throws Exception {
        System.out.println("@BeforeClass method invoked");
    }

    @AfterClass
    public static void afterClass() throws Exception {
        System.out.println("@AfterClass method invoked");
    }

    @Before
    public void before() throws Exception {
        System.out.println("@Before method invoked");
    }

    @After
    public void after() throws Exception {
        System.out.println("@After method invoked");
    }

    @Test
    public void generateUuid_not_null() {
        System.out.println("test method generateUuid_not_null() invoked");
        Assert.assertNotNull(userService.generateUuid());
    }

    @Test
    public void generateUuid_not_equals() {
        System.out.println("test method generateUuid_not_equals() invoked");
        Assert.assertNotEquals(userService.generateUuid(), userService.generateUuid());
    }
}
```

执行结果如下：

```
@BeforeClass method invoked
@Before method invoked
test method generateUuid_not_equals() invoked
@After method invoked
@Before method invoked
test method generateUuid_not_null() invoked
@After method invoked
@AfterClass method invoked
```

## 2.3 断言机制

#### 2.3.1 断言机制及断言增强

断言是单元测试中最基本、最核心、最重要的概念。我们可以将断言理解为一个语句是否成立。junit 最初的断言，只支持最基本的功能，即：两个值是否相同、结果是否为空指针、结果是否为 True（或者 False），且增加失败时的信息输出。

通用格式如下（**谓主宾格式**）：

```
Assert.assertEquals([optional]message, expected, actual);
```

支持的功能如下：

- assertEquals / assertNotEquals / assertArrayEquals -- 相等 / 不等 / 数组相等
- assertTrue / assertFalse -- 结果为 True / 结果为 False
- assertNull / assertNotNull -- 结果为 null / 结果不为 null
- assertSame / assertNotSame -- 结果是同一个对象 / 结果不是同一个对象
- assertThrows -- 执行器是否抛出指定异常
- fail -- 直接失败

我们写了一个示例，如下所示：

```
@Test
public void testAssert() {
    Assert.assertEquals(1L, 1L);
    Assert.assertNotEquals(1L, 2L);

    Assert.assertNotNull(new Object());
    Assert.assertNull(null);

    Assert.assertTrue(true);
    Assert.assertFalse(false);

    Assert.assertNotSame("the two objects not same", new Object(), new Object());

    final Object sameObj = new Object();
    Assert.assertSame("sameObj is not same of sameObj", sameObj, sameObj);

    final int[] expecteds = {1, 2, 3};
    final int[] actuals = {1, 2, 3};
    Assert.assertArrayEquals(expecteds, actuals);
}
```

这种断言机制引入之后，极大地增强了代码的可读性和完整性。不过，事情总是朝着好的方向发展。junit 社区有人反馈，认为这种反人类语言的格式不是很好用，junit 作者也善意地采纳了其意见，并决定在后期版本中加入更易懂的方式（**主谓宾格式**），以便更亲近人类，这种方式的语义更直观。所以，junit 引入了 `assertThat`，它使用 `Matcher` （匹配器）来完成它的职责，`Matcher` 本质上是使用链式编程的方式实现引用代入。核心的 `Matcher` 都是放在 `org.hamcrest.CoreMatchers` 类里面的。具体的匹配器是存放在 `org.hamcrest.core.*` 包下面的，

junit 实际上是通过间接依赖的方式，依赖了 `hamcrest` 类库。其依赖关系如下：

```
junit
    -> hamcrest-core (scope: compile)
    -> hamcrest-library (scope: test)
```

匹配器通用格式如下：

```
assertThat(actual, Matcher<? super T> matcher);
```

完整示例如下：

```
@Test
public void testAssertThat() {
    final int id = 3;
    MatcherAssert.assertThat(id, is(3));
    MatcherAssert.assertThat(id, is(not(4)));

    final boolean trueValue = true;
    MatcherAssert.assertThat(trueValue, is(true));

    final boolean falseValue = false;
    MatcherAssert.assertThat(falseValue, is(false));

    final Object nullObject = null;
    MatcherAssert.assertThat(nullObject, nullValue());

    final String helloWord = "Hello xxx World";
    MatcherAssert.assertThat(helloWord, both(startsWith("Hello")).and(endsWith("World")));
}
```

#### 2.3.2 自定义Matcher

有时，junit 自带的 `Matcher` 并不能完成我们想要完成的匹配，这时我们就需要自定义 `Matcher`，以此来用于特定语境下的特定处理。`org.hamcrest.Matcher` 是一个接口，它的注释上明确写明，不能直接继承它，需要继承 `org.hamcrest.BaseMatcher`。引用其注释如下：

> Matcher implementations should NOT directly implement this interface. Instead, extend the BaseMatcher abstract class, which will ensure that the Matcher API can grow to support new features and remain compatible with all Matcher implementations.

举例来说，我们想要实现这样的 `Matcher`，用于判断 User 对象的 username 和 password 都是 admin。这种应用场景虽然比较另类，但是也是有可能的，这儿我们实现自己的 `Matcher`，代码如下：

```
class User {
    private String username;
    private String password;
    // omited...
}
/**
 * <p>
 * Matcher implementations should <b>NOT directly implement this interface</b>.
 * Instead, <b>extend</b> the {@link BaseMatcher} abstract class,
 * which will ensure that the Matcher API can grow to support
 * new features and remain compatible with all Matcher implementations.
 * <p/>
 * @see org.hamcrest.Matcher
 */
class IsAdminMatcher extends BaseMatcher<User> {

    @Override
    public boolean matches(Object item) {
        if (item == null) {
            return false;
        }

        User user = (User) item;
        return "admin".equals(user.getUsername()) && "admin".equals(user.getPassword());
    }

    /**
     * real description about the actual value
     *
     * @param description the simple description obj
     */
    @Override
    public void describeTo(Description description) {
        description.appendText("Administrator with 'admin' as username and password");
    }

    /**
     * while meeting assert fail, it will be printed out
     *
     * @param item actual value
     * @param description the simple description obj
     */
    @Override
    public void describeMismatch(Object item, Description description) {
        if (item == null) {
            description.appendText("was null");
        } else {
            User user = (User) item;
            description.appendText("was a common user (")
                    .appendText("username: ").appendText(user.getUsername()).appendText(", ")
                    .appendText("password: ").appendText(user.getPassword()).appendText(")");
        }
    }
}
```

使用时，可参考下面这种写法。

```
User user = new User("admin", "admin");
Assert.assertThat(user, new IsAdminMatcher());
```

## 2.4 高级特性

#### 2.4.1 suite，聚合test cases

suite，顾名思义，就是套件的意思。在 junit 中，它主要用于将一堆 test cases 聚合起来，形成一个套件。suite 有两种使用方式，一种为硬编码方式，另一种为注解方式。

> 【注】：可以将 TestSuite 看成一种特殊的 Test。从代码层面我们也可以看出，TestSuite 继承了 Test。

首先，假设我们有以下的 test cases：

```
public class DemoTest {

    public static class TestSuite2 {
        public static junit.framework.Test suite() {
            TestSuite suite = new TestSuite("Test for package2");

            suite.addTest(new JUnit4TestAdapter(Test4.class));
            suite.addTest(new JUnit4TestAdapter(Test5.class));
            return suite;
        }
    }

    public static class Test1 {

        @Test
        public void test1() {
            System.out.println("test1 invoked");
        }
    }

    public static class Test2 {

        @Test
        public void test2() {
            System.out.println("test2 invoked");
        }
    }

    public static class Test3 {

        @Test
        public void test3() {
            System.out.println("test3 invoked");
        }
    }

    public static class Test4 {

        @Test
        public void test4() {
            System.out.println("test4 invoked");
        }
    }

    public static class Test5 {

        @Test
        public void test5() {
            System.out.println("test5 invoked");
        }
    }
}
```

其中 TestSuite2 可以看成是 Test4 和 Test5 的组合，现在我们想将 Test1、Test2、Test3 和 TestSuite2 组合起来一起执行，应该怎么办呢？这时候就该 suite 上场了。

1、硬编码方式

```
public class Suite1Test {

    public static Test suite() {
        TestSuite suite = new TestSuite("Test for package1");

        suite.addTest(new JUnit4TestAdapter(DemoTest.Test1.class));
        suite.addTest(new JUnit4TestAdapter(DemoTest.Test2.class));
        suite.addTest(new JUnit4TestAdapter(DemoTest.Test3.class));

        suite.addTest(DemoTest.TestSuite2.suite());
        return suite;
    }
}
```

2、注解方式

```
@RunWith(Suite.class)
@Suite.SuiteClasses({
        DemoTest.Test1.class,
        DemoTest.Test2.class,
        DemoTest.Test3.class,
        DemoTest.TestSuite2.class
})
public class Suite2Test {
}
```

综合分析，注解方式代码更少、更简洁，在实际项目中，我们更偏向使用注解方式。另外需要注意的是，TestSuite 应该有一个 **public static junit.framework.Test suite()** 方法。

#### 2.4.2 参数化测试

它可以看做是 suite 的一种特例，目的是为了对 test case 进行多次执行，以达到较为全面的覆盖。参数化测试需要以一种特殊的 Runner 执行，**@RunWith(Parameterized.class)**。下面我们以斐波那契算法来举例。

> 关于什么是斐波那契序列，请移步百度百科。

```
public class Fibonacci {

    public static int compute(int n) {
        if (n < 0) {
            return 0;
        }

        if (n == 0 || n == 1) {
            return n;
        }

        return compute(n - 1) + compute(n - 2);
    }
}

@RunWith(Parameterized.class)
public class FibonacciTest {

    /**
     * In order to easily identify the individual test cases in a Parameterized test,
     * you may provide a name using the @Parameters annotation.
     * This name is allowed to contain placeholders that are replaced at runtime:<br>
     * {index}: the current parameter index<br>
     * {0}, {1}, …: the first, second, and so on, parameter value. NOTE: single quotes ' should be escaped as two single quotes ''.<br>
     * <p/>
     * In the example given above, the Parameterized runner creates names like [1: fib(3)=2].
     * If you don't specify a name, the current parameter index will be used by default.
     *
     * @return
     */
    //@Parameterized.Parameters
    @Parameterized.Parameters(name = "{index}: fib({0})={1}")
    public static Collection data() {
        List<Object[]> list = new ArrayList<>();
        list.add(new Object[] {0, 0});
        list.add(new Object[] {1, 1});
        list.add(new Object[] {2, 1});
        list.add(new Object[] {3, 2});
        list.add(new Object[] {4, 3});
        list.add(new Object[] {5, 5});
        list.add(new Object[] {6, 8});
        return list;
    }

    private int input;
    private int expected;

    public FibonacciTest(int input, int expected) {
        this.input = input;
        this.expected = expected;
    }

    @Test
    public void test() {
        Assert.assertEquals(expected, Fibonacci.compute(input));
    }
}
```

执行结果如下：

```
【成功】com.juconcurrent.learn.unittest.c01.FibonacciTest
    【成功】[0: fib(0)=0]
    【成功】[1: fib(1)=1]
    【成功】[2: fib(2)=1]
    【成功】[3: fib(3)=2]
    【成功】[4: fib(4)=3]
    【成功】[5: fib(5)=5]
    【成功】[6: fib(6)=8]
```

这儿我们可以给参数取一个名字，一般情况下使用默认的就可以了。

个人觉得，参数化测试带来了一些弊端。即：如果有多个 test case 需要进行参数化，需要增加多个测试类。这种方式的粒度为类，而不是方法。在后面的特性中，我们会介绍解决这种问题的方法。

#### 2.4.3 自定义Rule

自定义规则的意图是为了丰富 test case，增加其灵活性。我们可以简单地罗列一些场景：

- 循环执行 **N** 次，**N** 为一个变量；
- 满足条件时，执行 **M** 次，不满足条件时，执行 **N** 次；
- 循环执行，直到条件满足时跳出循环。

这些场景中，如果我们把 test case 看成一个单元，规则就是在 filter 这个单元的时候，对其进行判断、循环和额外逻辑处理的 `Runner`。这种机制极大地满足了某些应用场景，且增加了单元测试的灵活性。

下面我们以一个例子来演示：

1. 定义规则注解

```
@Retention(RetentionPolicy.RUNTIME)
@Target({java.lang.annotation.ElementType.METHOD})
public @interface Repeat {
    int times();
}
```

1. 定义规则

```
class RepeatRule implements TestRule {

    private static class RepeatStatement extends Statement {

        private final int times;
        private final Statement statement;

        private RepeatStatement(int times, Statement statement) {
            this.times = times;
            this.statement = statement;
        }

        @Override
        public void evaluate() throws Throwable {
            for (int i = 0; i < times; i++) {
                statement.evaluate();
            }
        }
    }

    @Override
    public Statement apply(Statement statement, Description description) {
        Statement result = statement;
        Repeat repeat = description.getAnnotation(Repeat.class);
        if (repeat != null) {
            int times = repeat.times();
            result = new RepeatStatement(times, statement);
        }
        return result;
    }
}
```

1. 使用规则

```
public class TestRuleTest {

    // 这儿是重点
    @Rule
    public RepeatRule repeatRule = new RepeatRule();

    @Test
    @Repeat(times = 100)
    public void testCalculateRangeValue() {
        long center = 0;
        long radius = 10;
        RandomRangeValueCalculator calculator = new RandomRangeValueCalculator();

        long actual = calculator.calculateRangeValue(center, radius);
        System.out.println(actual);

        Assert.assertTrue(center + radius >= actual);
        Assert.assertTrue(center - radius <= actual);
    }
}
```

#### 2.4.4 分组测试（Categories）

分组测试，其实也属于一种特殊的 suite，用于对 test case 进行分组。并使用 **@RunWith(Categories.class)** 来执行和筛除分组的 test case。下面以一个例子来清晰表明如何进行分组测试。

1. 定义分组

```
// 声明两个什么都没有的接口
public interface FastTests { }
public interface SlowTests { }
```

1. 编写单元测试

```
public class ATest {

    @Test
    public void a() {
        System.out.println("A a()");
    }

    @Category(SlowTests.class)
    @Test
    public void b() {
        System.out.println("A b()");
    }
}

@Category({SlowTests.class, FastTests.class})
public class BTest {

    @Test
    public void c() {
        System.out.println("B c()");
    }
}
```

1. 编写分组suite

```
@RunWith(Categories.class) // 这个地方与一般的套件测试有所不同
@Categories.IncludeCategory(SlowTests.class)
@Suite.SuiteClasses({
        ATest.class,
        BTest.class
}) // Note that Categories is a kind of Suite
public class SlowTestSuite1 {
}
@RunWith(Categories.class)
@Categories.IncludeCategory(SlowTests.class)
@Categories.ExcludeCategory(FastTests.class)
@Suite.SuiteClasses({
        ATest.class,
        BTest.class
})
public class SlowTestSuite2 {
}
```

执行结果如下：

```
【成功】SlowTestSuite1
    【成功】ATest
    【成功】BTest
【成功】SlowTestSuite2
    【成功】ATest
```

#### 2.4.5 假设机制（assume）

假设机制是用于在条件满足时执行 test case、条件不满足时忽略 test case 的特殊机制。它使用 **assumeThat** 来进行判断。

```
public class AssumeTest {

    @Test
    public void testOneEqualsOne() {
        // sample for actual
        // assumeThat(File.separatorChar, is('/'));
        // System.out.println("is executed");
        assumeThat('1', is('1'));
        System.out.println("1 == 1");
    }

    @Test
    public void testOneNotEqualsTwo() {
        assumeThat('1', is('2'));
        System.out.println("1 == 2");
    }
}
```

执行结果如下：

```
【成功】AssumeTest
    【成功】testOneEqualsOne
    【忽略】testOneNotEqualsTwo
```

#### 2.4.6 理论机制（Theories）

Theories，英文意思为理论、推断。它是一种特殊的 Runner，提供了除 Parameterized 之外的另外一个更为强大的参数化测试解决方案。

Theories 不是使用带参的构造方法，而是使用受参的测试方法。test case 的修饰注解也从 `@Test` 变成了 `@Theory`。参数的提供也变成了 `@DataPoint` 或者 `@Datapoints`。这 2 个参数的不同之处在于前者代表一个数据，后者代表一组数据。Theories 会尝试所有类型匹配的参数作为测试方法的入参。

我们来看一个简单的例子。

```
@RunWith(Theories.class)
public class UserTest {

    public static String GOOD_USERNAME = "optimus";
    @DataPoint
    public static String USERNAME_ONE = "optimus1";
    @DataPoint
    public static String USERNAME_WITH_SLASH = "optimus2/prime";
    @DataPoints
    public static String[] USERNAMES = {"optimus3", "optimus4/prime"};

    @Theory
    public void filenameIncludesUsername(String username) {
        assumeThat(username, not(containsString("/")));

        System.out.println("username: " + username);

        assertThat(username, not(GOOD_USERNAME));
        assertThat(new User(username).configFileName(), containsString(username));
    }

    static class User {

        private String username;

        public User(String username) {
            this.username = username;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String configFileName() {
            return username + "/sb";
        }
    }
}
```

因为有 **assumeThat(username, not(containsString("/")));**，所以只有不带 “/” 的参数才会被带入。

上述代码执行结果如下：

```
username: optimus1
username: optimus3
```

Theories 还支持自定义数据的方式，需要继承 junit 的 `ParameterSupplier`。

1. 定义参数注解

```
@Retention(RetentionPolicy.RUNTIME)
@ParametersSuppliedBy(BetweenSupplier.class)
@interface Between {
    int first();

    int last();
}
```

1. 提供参数支持类，继承 `ParameterSupplier` 类

```
public class BetweenSupplier extends ParameterSupplier {

    @Override
    public List<PotentialAssignment> getValueSources(ParameterSignature sig) {
        Between annotation = sig.getAnnotation(Between.class);

        List<PotentialAssignment> list = new ArrayList<>();
        for (int i = annotation.first(); i <= annotation.last(); i++) {
            list.add(PotentialAssignment.forValue("value", i));
        }
        return list;
    }
}
```

1. test case 使用参数注解

```
@RunWith(Theories.class)
public class Dollar1Test {

    @Theory
    public void multiplyIsInverseOfDivideWithInlineDataPoints(
            @Between(first = -100, last = 100) int amount,
            @Between(first = -100, last = 100) int m) {
        assumeThat(m, not(0));
        System.out.println(amount + ":" + m);
        assertThat(new Dollar(amount).times(m).divideBy(m).getAmount(), is(amount));
    }
}
```

junit 自带了 `TestedOn` 注解，用于输入一个 int 数组，示例代码如下：

```
@RunWith(Theories.class)
public class Dollar2Test {

    @Theory
    public final void test(@TestedOn(ints = {0, 1, 2}) int i) {
        assertTrue(i >= 0);
    }

    @Theory
    public void multiplyIsInverseOfDivide(
            @TestedOn(ints = {0, 5, 10}) int amount,
            @TestedOn(ints = {0, 1, 2}) int m) {
        assumeThat(m, not(0));
        assertThat(new Dollar(amount).times(m).divideBy(m).getAmount(), is(amount));
    }
}
```

#### 2.4.7 多线程下的单元测试

在多线程下，单元测试很难保证线程安全。junit 并没有直接提供多线程环境下的测试机制，但是指明了使用某些第三方类库可以达到这样的目的。concurrentunit 就是其中的一种，在 gradle 下面，我们可以使用 **compile 'net.jodah:concurrentunit:${version}'** 引入依赖。下面我们提供一个非常简单的多线程示例，`Waiter` 提供了类似 `CountDownLatch` 机制，关于什么是 `CountDownLatch`，请自行百度。

```
@Test
public void shouldSupportMultipleThreads() throws Throwable {
    final Waiter waiter = new Waiter();

    for (int i = 0; i < 5; i++) {
        new Thread(new Runnable() {
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    System.out.println(e.getLocalizedMessage() + e);
                }
                waiter.assertTrue(true);
                waiter.resume();
            }
        }).start();
    }

    waiter.await();
}
```

# 三、mock技术

## 3.1 什么是mock？

mock 是 “mock测试” 的简写，也叫模拟测试。mock 就是在测试过程中，对于一些不容易构造或者不容易获取的对象，用一个虚拟的的对象来创建，使得测试工作能够顺利进行的测试方法。

mock 可以分解在单元测试中耦合的其他类或者接口，它能帮助模拟这些依赖，并验证调用依赖的行为。

那么，哪些对象需要用到 mock 呢？

1. 真实对象很难创建（依赖于具体环境）
2. 真实对象的某些行为很难触发，或者具有随机性
3. 真是对象可能依赖于实现方（只提供接口，不提供实现）

## 3.2 为什么要使用mock？

使用 mock 技术能带来如下好处。

- TDD，测试驱动开发。

- - TDD 的基础是单元测试，写单元测试的时候，可能被测试类还没有写好，这时需要对其进行 mock。

- 可以模拟那些访问不太稳定的系统（比如：有防火墙或ip白名单的系统）。

- 系统隔离（比如数据库、消息队列等）。

- - 从依赖数据库，变为不依赖数据库。所有数据库操作，全部变为 mock 的了。

- 提高测试覆盖率。

- - 领导比较看重这块。

## 3.3 常见的mock框架

市面上的 mock 框架非常多，常见的有 Mockito、PowerMock、JMockit、Easymock 等等。在这些框架里面，Mockito 是 Java 单元测试领域使用率最高的框架之一，而 PowerMock 针对 Mockito 做了一些功能的增强。

1. Mockito -- 操作起来非常自然的一种框架。

2. PowerMock -- 在 Mockito 的基础上进行了增强，支持 `static class`、`final class`、`constructor`、`private method` 等的 mock 操作。

3. 1. 【注意】：这些方法的 mock 需要谨慎使用，他们会破坏 OOP 的封装特性。

关于他们的对比，可以参考链接：https://blog.csdn.net/qq_41570658/article/details/120749254

## 3.4 Mockito框架介绍

#### 3.4.1 Mockito中的核心概念

Mockito 里面最重要的概念叫打桩（stub），也叫存根。其目的是模拟要调用的函数，给其提供桩函数。默认的桩函数实现会返回固定的值。

1. 如果是基本类型，那么返回基本类型的默认值（boolean 类型返回 false，int 类型返回 0，等等）。
2. 如果是集合类型，那么返回空集合。
3. 如果是其他的，那么返回 null。

#### 3.4.2 Mockito常用注解及方法

要使用 Mockito，必须使用 `@RunWith(MockitoJUnitRunner.class)` 或 `MockitoAnnotations.initMocks` 进行 mocks 的初始化和注入。

在 Mockito 中，常用的注解如下：

1. @Mock，用于模拟对象，有助于最大程度减少重复模拟的情况，在不使用注解的场景中，可考虑使用 `Mockito.mock(xxx.class)` 这种方式。
2. @Spy，用 spy 监控真实对象，设置真实对象行为。
3. @InjectMocks，Mockito 通过此注解会自动注入 mocks 对象到注解的变量中。因为注入失败的时候不会通知我们，所以需要我们自己对失败的对象做处理。

在 Mockito 中，常用的方法主要用于模拟和校验，如下所示：

1. `when(mock.someMethod(param1, param2, …)).thenReturn(returnValue);`

2. - mock对象某个方法调用时的返回值

3. `when(mock.someMethod(param1, param2, …)).thenThrow(new RuntimeException());`

4. - mock对象某个方法调用时抛出异常（方法本身有返回值）

5. `doThrow(new RuntimeException()).when(mock).someMethod(param1, param2, …);`

6. - mock对象某个方法调用时抛出异常（方法本身无返回值）

7. `verify(mock, times(5)).someMethod();`

8. - 验证mock对象某个方法是否执行、执行次数，可以为 `times(x)`、`atLeastOnce()`、`never()` 等。

9. `doCallRealMethod().when(xxxx);`

10. - mock对象需要调用真实方法。

#### 3.4.3 Mockito使用示例

接下来，让我们来看一个真实的例子。

1. 添加 Mockito 的依赖。

```
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
```

1. 定义 Mapper 类，这个类在单元测试中需要进行 mock 或 spy。

```
public class BookMapper {

    public List<String> list(String bookName) {
        List<String> bookNames = Arrays.asList("徐志摩诗歌集", "毛泽东诗歌集");
        System.out.println("list books, bookNames: " + bookNames);
        return bookNames;
    }
}
```

1. 定义 Service 类，这个类是需要测试的类。

```
public class BookServiceImpl implements BookService {

    private BookMapper bookMapper = new BookMapper();

    public List<String> listByBookName(String bookName) {
        if (bookName == null || bookName.trim().equals("")) {
            return Collections.emptyList();
        }
        return bookMapper.list(bookName);
    }
}
```

1. 我们针对测试类进行 mock 操作。

```
@RunWith(MockitoJUnitRunner.class)
public class BookServiceImpl4MockTest {

    @Mock
    private BookMapper bookMapper;
    @InjectMocks
    private BookServiceImpl bookService;

    @Test
    public void listMock() {
        // 执行mock，默认执行成功，且返回空集合。
        System.out.println("list mock for default start");
        List<String> defaultReturnValues = bookService.listByBookName("小说集");
        System.out.println("list mock for default, mockReturnValues: " + defaultReturnValues);
        System.out.println("list mock for default end");

        System.out.println("--------------");

        // doCallRealMethod() 表示执行真实方法
        // mock 对象只能对 public 和 protected 的方法进行 mock，对 private 方法，仍然会执行真实方法
        System.out.println("list mock for doCallRealMethod start");
        doCallRealMethod().when(bookMapper).list("诗歌集");
        List<String> realReturnValues = bookService.listByBookName("诗歌集");
        System.out.println("list mock for doCallRealMethod, realReturnValues: " + realReturnValues);
        System.out.println("list mock for doCallRealMethod end");

        System.out.println("--------------");

        // when 声明后，既不走真实方法，也不走默认 mock 方法，直接返回 thenReturn() 中定义的值
        System.out.println("list mock for when start");
        when(bookMapper.list("模拟集")).thenReturn(Collections.singletonList("模拟诗歌集"));
        List<String> mockReturnValues = bookService.listByBookName("模拟集");
        System.out.println("list mock for when, mockReturnValues: " + mockReturnValues);
        System.out.println("list mock for when end");
    }
}
```

我们看到，实际的输出和我们在代码段中写的注释说明是一致的。

```
list mock for default start
list mock for default, mockReturnValues: []
list mock for default end
--------------
list mock for doCallRealMethod start
list books, bookNames: [徐志摩诗歌集, 毛泽东诗歌集]
list mock for doCallRealMethod, realReturnValues: [徐志摩诗歌集, 毛泽东诗歌集]
list mock for doCallRealMethod end
--------------
list mock for when start
list mock for when, mockReturnValues: [模拟诗歌集]
list mock for when end
```

1. 我们针对测试类进行 spy 操作。

```
@RunWith(MockitoJUnitRunner.class)
public class BookServiceImpl4SpyTest {

    @Spy
    private BookMapper bookMapper;
    @InjectMocks
    private BookServiceImpl bookService;

    @Test
    public void listSpy() {
        // 默认执行真实方法。
        System.out.println("list spy for default start");
        List<String> defaultReturnValues = bookService.listByBookName("小说集");
        System.out.println("list spy for default, mockReturnValues: " + defaultReturnValues);
        System.out.println("list spy for default end");

        System.out.println("--------------");

        // doCallRealMethod() 表示执行真实方法，对于 @Spy 修饰的对象，其实不需要用到 doCallRealMethod()。
        System.out.println("list spy for doCallRealMethod start");
        doCallRealMethod().when(bookMapper).list("诗歌集");
        List<String> realReturnValues = bookService.listByBookName("诗歌集");
        System.out.println("list spy for doCallRealMethod, realReturnValues: " + realReturnValues);
        System.out.println("list spy for doCallRealMethod end");

        System.out.println("--------------");

        // when 声明后，仍然会执行真实方法，只是执行之后直接返回 thenReturn() 中定义的值。
        // 当 spy 对象的方法抛出异常后，就不会返回 thenReturn() 中定义的值，spy 方法也会将异常跑出来。
        System.out.println("list spy for when start");
        when(bookMapper.list("模拟集")).thenReturn(Collections.singletonList("模拟诗歌集"));
        List<String> mockReturnValues = bookService.listByBookName("模拟集");
        System.out.println("list spy for when, mockReturnValues: " + mockReturnValues);
        System.out.println("list spy for when end");
    }
}
```

我们看到，实际的输出也和我们在代码段中写的注释说明是一致的。

```
list spy for default start
list books, bookNames: [徐志摩诗歌集, 毛泽东诗歌集]
list spy for default, mockReturnValues: [徐志摩诗歌集, 毛泽东诗歌集]
list spy for default end
--------------
list spy for doCallRealMethod start
list books, bookNames: [徐志摩诗歌集, 毛泽东诗歌集]
list spy for doCallRealMethod, realReturnValues: [徐志摩诗歌集, 毛泽东诗歌集]
list spy for doCallRealMethod end
--------------
list spy for when start
list books, bookNames: [徐志摩诗歌集, 毛泽东诗歌集]
list spy for when, mockReturnValues: [模拟诗歌集]
list spy for when end
```

# 四、覆盖率

## 4.1 覆盖率指标

代码覆盖率是软件测试中的一种度量方式，用于描述程序中代码被测试的比例和程度。其定义如下：

> 代码覆盖率 ＝ 代码测试的覆盖程度，一种度量方式。
> 代码覆盖率 ＝ ( 代码执行覆盖量 / 代码总量 ) %

根据度量的粒度，覆盖率指标大致包含下面几种：

1. 类覆盖率。只要类被引用了，就算覆盖到了。
2. 方法覆盖率。调用了类的方法。
3. 行覆盖率（重要），也叫语句覆盖率。
4. 分支覆盖率。对于条件、循环等分支的覆盖率。
5. 条件覆盖率。条件覆盖率和分支覆盖率的区别在于，它更侧重于某个判断条件。
6. 路径覆盖率。即覆盖代码中的每条可能的路径。

我们举一个例子，用于计算两个数之和。

1. 如果两个数都大于 0，那么结果加上第一个数。
2. 如果两个数只要有一个小于 0，那么加上第二个数。
3. 上述 2 个条件是或的关系。

```
public class Calculator {

    /**
     * 加法运算
     *
     * @param first  第一个数
     * @param second 第二个数
     * @return 计算结果
     */
    public int add(int first, int second) {
        int result = 0;
        if (first > 0 && second > 0) {
            result += first;
        }
        if (first < 0 || second < 0) {
            result += second;
        }
        return result;
    }
}
```

#### 4.1.1 类覆盖率

```
public void testAdd4ClassConverage() {
    // 构造方法可以引用到类。
    new Calculator();
}
```

#### 4.1.2 方法覆盖率

```
public void testAdd4MethodConverage() {
    // 调用了类的方法，方法就算覆盖到了。
    new Calculator().add(1, 1);
}
```

#### 4.1.3 行覆盖率

```
public void testAdd4LineConverage() {
    // 第一次方法调用，覆盖了下面的行
    /*
    √    int result = 0;
    √    if (first > 0 && second > 0) {
    √        result += first;
         }
    √    if (first < 0 || second < 0) {
    ×        result += second;
         }
    √    return result;
    */
    new Calculator().add(1, 1);

    // 第二次方法调用，覆盖了下面的行
    /*
    √    int result = 0;
    √    if (first > 0 && second > 0) {
    ×        result += first;
         }
    √    if (first < 0 || second < 0) {
    √        result += second;
         }
    √    return result;
    */
    new Calculator().add(-1, -1);
}
```

如果希望方法的每一行都被覆盖到，那么需要调用两次被测试的方法。

#### 4.1.4 分支覆盖率

```
public void testAdd4BranchConverage() {
    // 第一次方法调用，覆盖了第一个分支
    /*
         int result = 0;
    √    if (first > 0 && second > 0) {
             result += first;
         }
    ×    if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(1, 1);

    // 第二次方法调用，覆盖了第二个分支
    /*
         int result = 0;
    ×    if (first > 0 && second > 0) {
             result += first;
         }
    √    if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(-1, -1);
}
```

我们可以将 “判断条件” 和 “代码块” 作为一个分支看待。只要能进入到 “代码块”，就可以认为分支覆盖到了。

在 Java 中，常见的分支种类有下面这些：

1. if
2. else
3. switch -> case
4. switch -> default
5. while
6. try -> catch
7. try -> finally

#### 4.1.5 条件覆盖率

```
public void testAdd4ConditionConverage() {
    // 第一次方法调用
    // 1. 第一个分支
    //     a. first > 0 覆盖了 true，没覆盖 false
    //     b. second > 0 覆盖了 true，没覆盖 false
    // 2. 第二个分支
    //     a. first < 0 覆盖了 false，没覆盖 true
    //     b. second < 0 覆盖 false，没覆盖 true
    /*
         int result = 0;
         if (first > 0 && second > 0) {
             result += first;
         }
         if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(1, 1);

    // 第二次方法调用
    // 1. 第一个分支
    //     a. first > 0 覆盖了 true，没覆盖 false
    //     b. second > 0 覆盖了 false，没覆盖 true
    // 2. 第二个分支
    //     a. first < 0 覆盖了 false，没覆盖 true
    //     b. second < 0 覆盖了 true，没覆盖 false
    /*
         int result = 0;
         if (first > 0 && second > 0) {
             result += first;
         }
         if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(1, -1);

    // 整体来说。
    // first > 0 覆盖了 true，没覆盖 false。部分覆盖了。
    // second > 0 覆盖了 true，覆盖了 false。都覆盖了。
    // first < 0 覆盖了 false，没覆盖 true。部分覆盖了。
    // second < 0  覆盖了 true，覆盖了 false。都覆盖了。
}
```

条件覆盖和分支覆盖类似，不过分支覆盖着眼于整个分支语句，而条件覆盖则着眼于某个判断条件。

条件覆盖需要保证每个判断条件的 true 和 false 都要覆盖到，而不是整个判定语句。

#### 4.1.6 路径覆盖率

路径覆盖，顾名思义就是覆盖所有可能执行的路径。

接下来，我们看一下示例的流程图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/X188DkJK31WHVuyYTWPmRRNswoNwzRZRl4ibbbicOYaJw7kb5td56KCJYXJH1rajwicsGLDmo8xGib5KbmYGZW6tHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

路径覆盖率流程图

首先梳理所有路径：

- 路径1：1-->3-->5
- 路径2：1-->2-->5
- 路径3：1-->3-->4
- 路径4：1-->2-->4

假如我们的测试代码如下所示：

```
public void testAdd4PathConverage() {
    // 第一次方法调用
    // 覆盖路径：1-->2-->5
    /*
         int result = 0;
         if (first > 0 && second > 0) {
             result += first;
         }
         if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(1, 1);

    // 第二次方法调用
    // 覆盖路径：1-->3-->5
    /*
         int result = 0;
         if (first > 0 && second > 0) {
             result += first;
         }
         if (first < 0 || second < 0) {
             result += second;
         }
         return result;
    */
    new Calculator().add(-1, -1);
}
```

上述代码的覆盖路径情况如下所示：

- 第一次方法调用，覆盖路径：1-->2-->5
- 第二次方法调用，覆盖路径：1-->3-->5

#### 4.1.7 总结

对于单元测试，这里需要特别说明一下。无论设计多少个测试用例，无论测试方案多么完美，都不可能完全（100%）地发现所有 BUG。我们需要做的就是用最少的资源，做最多的测试检查，从而寻找一个平衡点来保证程序的正确性。穷举测试是不可能的。所以常规的单元测试通常是选择一般常用的、访问频繁的基本路径测试法。

路径覆盖最完善，但是在一些复杂的场景里，会带来测试代码指数级增长的副作用，这个对于绝大多数人都是无法接受的。

一般情况下，行覆盖和判定覆盖同时做到已经是比较好的单测代码了。

## 4.2 覆盖率工具

在覆盖率工具层面，主要有下面两类：

1. Intellij IDEA 自带运行工具

2. Jacoco

3. 1. maven插件
   2. jenkins插件
   3. sonar插件
   4. …

关于 Jacoco 的使用，后面有时间的话，楼主会单独总结一篇文章。

# 五、单测实践

在开发服务端代码的时候，我们最常用的是 MVC 模式（三层模式），每一层的单元测试写法都会不一样。

1. M（模型层），也就是我们说的 service 层。这一层的单元测试需要我们重点写。
2. V（视图层），由于前后端分离架构的流行，这一层已经由前端架构代替（例如：vue、react、angular等），所以写服务端的哦们不需要太关心。
3. C（控制层），也就是我们说的 controller 层。这一层的单元测试写法有不同的多个变种。

## 5.1 controller层的测试

由于 junit 提供了 `Runner` 的扩展支持。而 Spring 基于它进行了扩展增强，所以我们的 `Runner` 可以有下面几种。

1. SpringRunner

2. - Spring boot 在它的基础上做了二次增强。可以使用注解 `SpringBootTest` 和 `AutoConfigureMockMvc`。

3. MockitoJUnitRunner

4. - Mockito 框架的核心 `Runner`，提供了 mock 机制。

因此，controller 层的测试，我们就可以基于不同的 Runner 来实现。

#### 5.1.1 SpringRunner入口的测试

我们提供一个示例，这个例子基于 “http协议” 访问入口的维度。它的访问又有 2 种方式，如下所示。

1. `TestRestTemplate`
2. `MockMvc`

有的时候，我们访问 controller会间接依赖其他的很多spring bean。例如：

```
controller 
    -> service1 -> dao -> 数据库 (中间件)
    -> servcie2 -> rabbitmq / kafka
    -> service3 -> remote service (rpc)
```

如果数据库、消息中间件或远程服务访问异常，那么就会导致单元测试失败。一种好的解决方案就是将 controller 依赖的组件全部 mock。这时，我们就需要用到 `@MockBean` 注解，用于 mock 掉 Spring 容器中的 Bean 实例。

```
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@RunWith(SpringRunner.class)
@AutoConfigureMockMvc
public class UserController1Test {

    @MockBean
    private UserService userService;
    @Autowired
    private TestRestTemplate testRestTemplate;
    @Autowired
    private MockMvc mockMvc;

    @Test
    public void test4UseTestRestTemplate() {
        // mock service 的行为
        final Long mockedUserId = 1L;
        final String mockedUserName = "sb9527";
        when(userService.getUsernameById(mockedUserId)).thenReturn(mockedUserName);

        // 拼装参数，并调用 controller 的接口
        Map<String, Object> urlVariables = new HashMap<>();
        urlVariables.put("id", mockedUserId);
        String result = testRestTemplate.getForObject("/user/getUsernameById?id={id}", String.class, urlVariables);

        // 校验结果
        Assert.assertEquals(mockedUserName, result);
    }

    @SneakyThrows
    @Test
    public void test4UseMockMvc() {
        // mock service 的行为
        final Long mockedUserId = 1L;
        final String mockedUserName = "sb9527";
        when(userService.getUsernameById(mockedUserId)).thenReturn(mockedUserName);

        // 拼装参数，并调用 controller 的接口
        MvcResult mvcResult = mockMvc.perform(
                MockMvcRequestBuilders.get("/user/getUsernameById?id={id}", mockedUserId)
                        .accept(MediaType.APPLICATION_JSON)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andDo(MockMvcResultHandlers.print())
                .andReturn();

        // 校验结果
        Assert.assertEquals(mockedUserName, mvcResult.getResponse().getContentAsString());
    }
}
```

#### 5.1.2 MockitoJUnitRunner入口的测试

我们提供两个示例。

第一个是基于 “controller类” 访问入口的维度。

```
@RunWith(MockitoJUnitRunner.class)
public class UserController2Test {

    @Mock
    private UserService userService;
    @InjectMocks
    private UserController userController;

    @Test
    public void test4UseMockito() {
        // mock service 的行为
        final Long mockedUserId = 1L;
        final String mockedUserName = "sb9527";
        when(userService.getUsernameById(mockedUserId)).thenReturn(mockedUserName);

        // 拼装参数，并调用 controller 的接口
        String result = userController.getUsernameById(mockedUserId);

        // 校验结果
        Assert.assertEquals(mockedUserName, result);
    }
}
```

第二个是基于 “http协议” 访问入口的维度。

```
@RunWith(MockitoJUnitRunner.class)
public class UserController3Test {

    @InjectMocks
    private UserController userController;
    @Mock
    private UserService userService;
    private MockMvc mockMvc;

    @Before
    public void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(userController).build();
    }

    @Test
    public void test4UseMockMvc() throws Exception {
        // mock service 的行为
        final Long mockedUserId = 1L;
        final String mockedUserName = "sb9527";
        when(userService.getUsernameById(mockedUserId)).thenReturn(mockedUserName);

        // 拼装参数，并调用 controller 的接口
        MvcResult mvcResult = mockMvc.perform(
                MockMvcRequestBuilders.get("/user/getUsernameById?id={id}", mockedUserId)
                        .accept(MediaType.APPLICATION_JSON)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andDo(MockMvcResultHandlers.print())
                .andReturn();

        // 校验结果
        Assert.assertEquals(mockedUserName, mvcResult.getResponse().getContentAsString());
    }
}
```

## 5.2 service层的测试

service 层完全可以基于 Mockito 的 `MockitoJUnitRunner` 来实现。除了一些极端的情况，例如：final 方法、构造方法、私有方法等等。

```
@RunWith(MockitoJUnitRunner.class)
public class UserServiceImplTest {

    @Mock
    private UserMapper userMapper;
    @InjectMocks
    private UserServiceImpl userService;

    @Test
    public void getUsernameById_when_not_fetch_user() {
        try {
            userService.getUsernameById(1L);
            Assert.fail("不应该取到用户信息");
        } catch (Exception ignored) {
        }
    }

    @Test
    public void getUsernameById_when_fetch_user() {
        // given
        final Long id = 1L;
        final String mockedUsername = "zhangsan";
        Mockito.when(userMapper.getById(id)).thenReturn(new User().setId(id).setUsername(mockedUsername));

        // when
        String dbUsername = userService.getUsernameById(id);

        // then
        Assert.assertEquals(mockedUsername, dbUsername);
    }
}
```

#### 5.3 测试规约

《阿里巴巴Java开发手册》对 “单元测试” 提出了十多条规约。这些规约更多的 是一些方法论和经验之谈，我们不采纳它也可以写出单元测试，只是在简单性、健壮性、扩展性等方面会有所缺陷而已。

接下来，我们罗列几个供大家参考。

1. 【强制】好的单元测试必须遵守 AIR 原则。
   说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，
   却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。
2. 【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执
   行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元
   测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。
3. 【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间
   决不能互相调用，也不能依赖执行的先后次序。
   反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。
4. 【强制】单元测试是可以重复执行的，不能受到外界环境的影响。
   说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如
   果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。
   正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring
   这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。
5. 【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级
   别，一般是方法级别。
   说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的
   交互逻辑，那是集成测试的领域。
6. 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。
   说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。
7. 【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。
   说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。

# 六、总结

很多公司并不是很重视单元测试，他们认为与其写这么多单元测试，还不如多写一些业务代码来得实在。在前期业务快速发展阶段，这种想法其实是没问题的。但是随着功能逐步内敛、系统趋于稳定的时候，如果我们仍然不重视单元测试，极有可能导致测试的周期被拉长、测试人力投入也会呈指数增长的情况出现。

有的公司会要求写单元测试，对单元测试中的覆盖率指标也有严格要求。覆盖率指标本身是好的，但是如果只是片面地提高覆盖率，而不考虑业务本身的测试特性的话，往往会以偏概全，难以发挥出测试代码的威力。

除此之外，如果我们无法给程序写单元测试，那么意味着我们的程序是有问题的，需要我们对此进行重构和优化。

对待测试代码，需要我们跟对待业务代码一样。测试代码和业务代码应该具有双赢增长的特性，这样才能可持续发展。

# 七、参考

1. JUnit和Mockito -- https://blog.csdn.net/weixin_45667674/article/details/115830903
2. SpringBoot与JUnit+Mockito 单元测试 -- https://zhuanlan.zhihu.com/p/21444517
3. 一款自动生成单元测试的 IDEA 插件 -- https://blog.csdn.net/weixin_43167418/article/details/124811459
4. Unit Test 系列文章 (写得很简陋) -- https://blog.csdn.net/qq_41055045/article/details/119175969
5. hamcrest详细介绍 -- https://blog.csdn.net/demon7552003/article/details/85867516
6. JAVA单元测试那些事儿 -- https://baijiahao.baidu.com/s?id=1721194726329463297&wfr=spider&for=pc
7. Java单元测试技巧之PowerMock -- https://developer.aliyun.com/article/782591
8. Java编程技巧之单元测试用例编写流程 -- https://www.cnblogs.com/yunqishequ/p/14767775.html
9. Java如何写一个好的单元测试 -- https://blog.csdn.net/dingyujiaoyu/article/details/118223661
10. java单元测试怎么写？怎么使用Junit进行单元测试 -- https://www.w3cschool.cn/article/93290547.html
11. Java单元测试用例的编写，有什么技巧？-- https://www.zhihu.com/question/449470796
12. Mock工具介绍，为什么使用Mock？-- https://blog.csdn.net/qq_41570658/article/details/120749254
13. 单元测试覆盖率类型 -- https://mp.weixin.qq.com/s/YeKLA8nvvKTYmumJq3TA3A
14. SpringBoot Web项目Mock测试 -- https://blog.csdn.net/qq_35261940/article/details/122113891